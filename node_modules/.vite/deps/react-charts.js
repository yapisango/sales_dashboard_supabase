import {
  require_react_dom
} from "./chunk-Y5BGZF4O.js";
import {
  require_react
} from "./chunk-H5FQS3OF.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(r, a2) {
  (null == a2 || a2 > r.length) && (a2 = r.length);
  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
  return n;
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(r, a2) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a2);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a2) : void 0;
  }
}

// node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelperLoose.js
function _createForOfIteratorHelperLoose(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (t) return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
    t && (r = t);
    var o = 0;
    return function() {
      return o >= r.length ? {
        done: true
      } : {
        done: false,
        value: r[o++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/d3-array/src/ascending.js
function ascending_default(a2, b) {
  return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector_default(f) {
  let delta = f;
  let compare = f;
  if (f.length === 1) {
    delta = (d, x2) => f(d) - x2;
    compare = ascendingComparator(f);
  }
  function left(a2, x2, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a2.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a2[mid], x2) < 0) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }
  function right(a2, x2, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a2.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a2[mid], x2) > 0) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }
  function center(a2, x2, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a2.length;
    const i = left(a2, x2, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
  }
  return { left, center, right };
}
function ascendingComparator(f) {
  return (d, x2) => ascending_default(f(d), x2);
}

// node_modules/d3-array/src/number.js
function number_default(x2) {
  return x2 === null ? NaN : +x2;
}
function* numbers(values, valueof) {
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector_default(number_default).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/extent.js
function extent_default(values, valueof) {
  let min3;
  let max3;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null) {
        if (min3 === void 0) {
          if (value >= value) min3 = max3 = value;
        } else {
          if (min3 > value) min3 = value;
          if (max3 < value) max3 = value;
        }
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null) {
        if (min3 === void 0) {
          if (value >= value) min3 = max3 = value;
        } else {
          if (min3 > value) min3 = value;
          if (max3 < value) max3 = value;
        }
      }
    }
  }
  return [min3, max3];
}

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(value);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// node_modules/d3-array/src/identity.js
function identity_default(x2) {
  return x2;
}

// node_modules/d3-array/src/group.js
function groups(values, ...keys) {
  return nest(values, Array.from, identity_default, keys);
}
function nest(values, map4, reduce2, keys) {
  return function regroup(values2, i) {
    if (i >= keys.length) return reduce2(values2);
    const groups2 = new InternMap();
    const keyof2 = keys[i++];
    let index2 = -1;
    for (const value of values2) {
      const key = keyof2(value, ++index2, values2);
      const group2 = groups2.get(key);
      if (group2) group2.push(value);
      else groups2.set(key, [value]);
    }
    for (const [key, values3] of groups2) {
      groups2.set(key, regroup(values3, i));
    }
    return map4(groups2);
  }(values, 0);
}

// node_modules/d3-array/src/permute.js
function permute_default(source, keys) {
  return Array.from(keys, (key) => source[key]);
}

// node_modules/d3-array/src/sort.js
function sort(values, ...F) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values = Array.from(values);
  let [f = ascending_default] = F;
  if (f.length === 1 || F.length > 1) {
    const index2 = Uint32Array.from(values, (d, i) => i);
    if (F.length > 1) {
      F = F.map((f2) => values.map(f2));
      index2.sort((i, j) => {
        for (const f2 of F) {
          const c = ascending_default(f2[i], f2[j]);
          if (c) return c;
        }
      });
    } else {
      f = values.map(f);
      index2.sort((i, j) => ascending_default(f[i], f[j]));
    }
    return permute_default(values, index2);
  }
  return values.sort(f);
}

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function ticks_default(start, stop, count2) {
  var reverse2, i = -1, n, ticks, step;
  stop = +stop, start = +start, count2 = +count2;
  if (start === stop && count2 > 0) return [start];
  if (reverse2 = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count2)) === 0 || !isFinite(step)) return [];
  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    if (r0 * step < start) ++r0;
    if (r1 * step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    if (r0 / step < start) ++r0;
    if (r1 / step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) / step;
  }
  if (reverse2) ticks.reverse();
  return ticks;
}
function tickIncrement(start, stop, count2) {
  var step = (stop - start) / Math.max(0, count2), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function tickStep(start, stop, count2) {
  var step0 = Math.abs(stop - start) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

// node_modules/d3-array/src/max.js
function max(values, valueof) {
  let max3;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  }
  return max3;
}

// node_modules/d3-array/src/min.js
function min(values, valueof) {
  let min3;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (min3 > value || min3 === void 0 && value >= value)) {
        min3 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (min3 > value || min3 === void 0 && value >= value)) {
        min3 = value;
      }
    }
  }
  return min3;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array2, k2, left = 0, right = array2.length - 1, compare = ascending_default) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k2 - left + 1;
      const z = Math.log(n);
      const s2 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k2 - m * s2 / n + sd));
      const newRight = Math.min(right, Math.floor(k2 + (n - m) * s2 / n + sd));
      quickselect(array2, k2, newLeft, newRight, compare);
    }
    const t = array2[k2];
    let i = left;
    let j = right;
    swap(array2, left, k2);
    if (compare(array2[right], t) > 0) swap(array2, left, right);
    while (i < j) {
      swap(array2, i, j), ++i, --j;
      while (compare(array2[i], t) < 0) ++i;
      while (compare(array2[j], t) > 0) --j;
    }
    if (compare(array2[left], t) === 0) swap(array2, left, j);
    else ++j, swap(array2, j, right);
    if (j <= k2) left = j + 1;
    if (k2 <= j) right = j - 1;
  }
  return array2;
}
function swap(array2, i, j) {
  const t = array2[i];
  array2[i] = array2[j];
  array2[j] = t;
}

// node_modules/d3-array/src/quantile.js
function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return min(values);
  if (p >= 1) return max(values);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

// node_modules/d3-array/src/median.js
function median_default(values, valueof) {
  return quantile(values, 0.5, valueof);
}

// node_modules/d3-array/src/range.js
function range_default(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = new Array(n);
  while (++i < n) {
    range[i] = start + i * step;
  }
  return range;
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle(array2, i0 = 0, i1 = array2.length) {
    let m = i1 - (i0 = +i0);
    while (m) {
      const i = random() * m-- | 0, t = array2[m + i0];
      array2[m + i0] = array2[i + i0];
      array2[i + i0] = t;
    }
    return array2;
  };
}

// node_modules/d3-array/src/sum.js
function sum(values, valueof) {
  let sum3 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value = +value) {
        sum3 += value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index2, values)) {
        sum3 += value;
      }
    }
  }
  return sum3;
}

// node_modules/react-charts/es/components/Chart.js
var import_react16 = __toESM(require_react());

// node_modules/react-charts/es/hooks/useGetLatest.js
var import_react = __toESM(require_react());
function useGetLatest(obj) {
  var ref = import_react.default.useRef(obj);
  var getterRef = import_react.default.useRef();
  ref.current = obj;
  if (!getterRef.current) {
    getterRef.current = function() {
      return ref.current;
    };
  }
  return getterRef.current;
}

// node_modules/react-charts/es/hooks/useIsomorphicLayoutEffect.js
var import_react2 = __toESM(require_react());
var useIsomorphicLayoutEffect_default = typeof window !== "undefined" ? import_react2.default.useLayoutEffect : import_react2.default.useEffect;

// node_modules/react-charts/es/seriesTypes/Bar.js
var import_react3 = __toESM(require_react());

// node_modules/react-charts/es/utils/Utils.js
function getSeriesStatus(series, focusedDatum) {
  if ((focusedDatum == null ? void 0 : focusedDatum.seriesId) === series.id) {
    return "focused";
  }
  return "none";
}
function getDatumStatus(datum, focusedDatum) {
  var _datum$tooltipGroup;
  if (datum === focusedDatum) {
    return "focused";
  }
  if ((_datum$tooltipGroup = datum.tooltipGroup) != null && _datum$tooltipGroup.some(function(groupDatum) {
    groupDatum.seriesId === (focusedDatum == null ? void 0 : focusedDatum.seriesId) && groupDatum.index === (focusedDatum == null ? void 0 : focusedDatum.index);
  })) {
    return "groupFocused";
  }
  return "none";
}
var elementTypes = ["area", "line", "rectangle", "circle"];
function materializeStyles(style, defaults) {
  if (style === void 0) {
    style = {};
  }
  if (defaults === void 0) {
    defaults = {};
  }
  style = normalizeColor(style, defaults);
  for (var i = 0; i < elementTypes.length; i++) {
    var type = elementTypes[i];
    if (style[type] && defaults[type]) {
      style[type] = materializeStyles(style[type], defaults);
    }
  }
  return style;
}
function translate(x2, y2) {
  return "translate3d(" + Math.round(x2) + "px, " + Math.round(y2) + "px, 0)";
}
function normalizeColor(style, defaults) {
  return _extends({}, style, {
    stroke: style.stroke || style.color || defaults.stroke || defaults.color,
    fill: style.fill || style.color || defaults.fill || defaults.color
  });
}
function isDefined(num) {
  return typeof num === "number" && !Number.isNaN(num);
}

// node_modules/react-charts/es/utils/chartContext.js
var React3 = __toESM(require_react());
var chartContext = React3.createContext(null);
function ChartContextProvider(_ref) {
  var value = _ref.value, children = _ref.children;
  return React3.createElement(chartContext.Provider, {
    value,
    children
  });
}
function useChartContext() {
  return React3.useContext(chartContext)();
}

// node_modules/react-charts/es/seriesTypes/Bar.js
function BarComponent(_ref) {
  var primaryAxis = _ref.primaryAxis, secondaryAxis = _ref.secondaryAxis, allSeries = _ref.series;
  var _useChartContext = useChartContext(), getSeriesStatusStyle = _useChartContext.getSeriesStatusStyle, getDatumStatusStyle = _useChartContext.getDatumStatusStyle, focusedDatumState = _useChartContext.focusedDatumState, gridDimensions = _useChartContext.gridDimensions;
  var focusedDatum = focusedDatumState[0];
  var xAxis = primaryAxis.isVertical ? secondaryAxis : primaryAxis;
  var yAxis = primaryAxis.isVertical ? primaryAxis : secondaryAxis;
  return import_react3.default.createElement("g", {
    style: {
      transform: translate(gridDimensions.left, gridDimensions.top)
    }
  }, allSeries.map(function(series, i) {
    var style = getSeriesStatusStyle(series, focusedDatum);
    return import_react3.default.createElement("g", {
      key: "lines-" + i
    }, series.datums.map(function(datum, i2) {
      var _getRectX, _getWidth, _getRectY, _getHeight;
      var dataStyle = getDatumStatusStyle(datum, focusedDatum);
      var _clampPxToAxis = clampPxToAxis((_getRectX = getRectX(datum, primaryAxis, secondaryAxis)) != null ? _getRectX : NaN, (_getWidth = getWidth(datum, primaryAxis, secondaryAxis)) != null ? _getWidth : NaN, xAxis), x2 = _clampPxToAxis[0], width = _clampPxToAxis[1];
      var _clampPxToAxis2 = clampPxToAxis((_getRectY = getRectY(datum, primaryAxis, secondaryAxis)) != null ? _getRectY : NaN, (_getHeight = getHeight(datum, primaryAxis, secondaryAxis)) != null ? _getHeight : NaN, yAxis), y2 = _clampPxToAxis2[0], height = _clampPxToAxis2[1];
      return import_react3.default.createElement("rect", {
        ref: function ref(el) {
          datum.element = el;
        },
        key: i2,
        x: x2,
        y: y2,
        width,
        height,
        style: _extends({
          strokeWidth: 0
        }, style, style.rectangle, dataStyle, dataStyle.rectangle)
      });
    }));
  }));
}
function getWidth(datum, primaryAxis, secondaryAxis) {
  return primaryAxis.isVertical ? getSecondaryLength(datum, secondaryAxis) : getPrimaryLength(datum, primaryAxis, secondaryAxis);
}
function getHeight(datum, primaryAxis, secondaryAxis) {
  return primaryAxis.isVertical ? getPrimaryLength(datum, primaryAxis, secondaryAxis) : getSecondaryLength(datum, secondaryAxis);
}
function getPrimaryGroupLength(_datum, primaryAxis) {
  return Math.max(primaryAxis.primaryBandScale.bandwidth(), 1);
}
function getPrimaryLength(_datum, primaryAxis, secondaryAxis) {
  if (primaryAxis.axisFamily === "band") {
    var _primaryAxis$minBandS, _primaryAxis$maxBandS;
    var bandWidth = secondaryAxis.stacked ? primaryAxis.scale.bandwidth() : primaryAxis.seriesBandScale.bandwidth();
    return Math.min(Math.max(bandWidth, (_primaryAxis$minBandS = primaryAxis.minBandSize) != null ? _primaryAxis$minBandS : 1), (_primaryAxis$maxBandS = primaryAxis.maxBandSize) != null ? _primaryAxis$maxBandS : 99999999);
  }
  return Math.max(secondaryAxis.stacked ? primaryAxis.primaryBandScale.bandwidth() : primaryAxis.seriesBandScale.bandwidth(), 1);
}
function getSecondaryLength(datum, secondaryAxis) {
  var secondary = [getSecondaryStart(datum, secondaryAxis), getSecondary(datum, secondaryAxis)];
  return Math.abs(secondary[1] - secondary[0]);
}
function getRectX(datum, primaryAxis, secondaryAxis) {
  return primaryAxis.isVertical ? getSecondaryStart(datum, secondaryAxis) : getPrimary(datum, primaryAxis, secondaryAxis);
}
function getRectY(datum, primaryAxis, secondaryAxis) {
  return primaryAxis.isVertical ? getPrimary(datum, primaryAxis, secondaryAxis) : getSecondary(datum, secondaryAxis);
}
function getPrimary(datum, primaryAxis, secondaryAxis) {
  var _primaryAxis$scale;
  var primary = (_primaryAxis$scale = primaryAxis.scale(datum.primaryValue)) != null ? _primaryAxis$scale : NaN;
  if (primaryAxis.axisFamily !== "band") {
    primary -= getPrimaryGroupLength(datum, primaryAxis) / 2;
  }
  if (!secondaryAxis.stacked) {
    var _seriesBandScale;
    primary = primary + ((_seriesBandScale = primaryAxis.seriesBandScale(datum.seriesIndex)) != null ? _seriesBandScale : NaN);
  }
  return primary;
}
function getSecondaryStart(datum, secondaryAxis) {
  var _secondaryAxis$scale2;
  if (secondaryAxis.stacked) {
    var _secondaryAxis$scale, _datum$stackData$, _datum$stackData;
    return (_secondaryAxis$scale = secondaryAxis.scale((_datum$stackData$ = (_datum$stackData = datum.stackData) == null ? void 0 : _datum$stackData[0]) != null ? _datum$stackData$ : NaN)) != null ? _secondaryAxis$scale : NaN;
  }
  return (_secondaryAxis$scale2 = secondaryAxis.scale(datum.secondaryValue < 0 ? datum.secondaryValue : 0)) != null ? _secondaryAxis$scale2 : NaN;
}
function getSecondary(datum, secondaryAxis) {
  var _secondaryAxis$scale4;
  if (secondaryAxis.stacked) {
    var _secondaryAxis$scale3, _datum$stackData$2, _datum$stackData2;
    return (_secondaryAxis$scale3 = secondaryAxis.scale((_datum$stackData$2 = (_datum$stackData2 = datum.stackData) == null ? void 0 : _datum$stackData2[1]) != null ? _datum$stackData$2 : NaN)) != null ? _secondaryAxis$scale3 : NaN;
  }
  return (_secondaryAxis$scale4 = secondaryAxis.scale(datum.secondaryValue < 0 ? 0 : datum.secondaryValue)) != null ? _secondaryAxis$scale4 : NaN;
}
function clampPxToAxis(startPx, lengthPx, axis) {
  var range = axis.scale.range();
  if (axis.isVertical) {
    range.reverse();
  }
  var safe = function safe2(num) {
    return Math.max(range[0], Math.min(num, range[1]));
  };
  var safeStart = safe(startPx);
  var safeEnd = safe(startPx + lengthPx);
  var safeLength = safeEnd - safeStart;
  return [safeStart, safeLength];
}

// node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon = 1e-6;
var tauEpsilon = tau - epsilon;
function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x2, y2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x2, y2) {
    this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  quadraticCurveTo: function(x1, y1, x2, y2) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (r < 0) throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else if (!(l01_2 > epsilon)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else {
      var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }
      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r < 0) throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }
    if (!r) return;
    if (da < 0) da = da % tau + tau;
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
    }
  },
  rect: function(x2, y2, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function() {
    return this._;
  }
};
var path_default = path;

// node_modules/d3-shape/src/constant.js
function constant_default2(x2) {
  return function constant() {
    return x2;
  };
}

// node_modules/d3-shape/src/math.js
var epsilon2 = 1e-12;
var pi2 = Math.PI;
var halfPi = pi2 / 2;
var tau2 = 2 * pi2;

// node_modules/d3-shape/src/array.js
var slice2 = Array.prototype.slice;
function array_default(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // proceed
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/point.js
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x2, y2) {
  var defined = constant_default2(true), context = null, curve = linear_default, output = null;
  x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x : constant_default2(x2);
  y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y : constant_default2(y2);
  function line(data) {
    var i, n = (data = array_default(data)).length, d, defined0 = false, buffer;
    if (context == null) output = curve(buffer = path_default());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x2(d, i, data), +y2(d, i, data));
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  line.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default2(+_), line) : x2;
  };
  line.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default2(+_), line) : y2;
  };
  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default2(!!_), line) : defined;
  };
  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };
  return line;
}

// node_modules/d3-shape/src/area.js
function area_default(x0, y0, y1) {
  var x1 = null, defined = constant_default2(true), context = null, curve = linear_default, output = null;
  x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant_default2(+x0);
  y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant_default2(0) : constant_default2(+y0);
  y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant_default2(+y1);
  function area(data) {
    var i, j, k2, n = (data = array_default(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null) output = curve(buffer = path_default());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined).curve(curve).context(context);
  }
  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default2(+_), x1 = null, area) : x0;
  };
  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default2(+_), area) : x0;
  };
  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant_default2(+_), area) : x1;
  };
  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default2(+_), y1 = null, area) : y0;
  };
  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default2(+_), area) : y0;
  };
  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant_default2(+_), area) : y1;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };
  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };
  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };
  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default2(!!_), area) : defined;
  };
  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };
  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };
  return area;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a2, r) {
    this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
  }
};
function curveRadial(curve) {
  function radial2(context) {
    return new Radial(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = Math.sqrt(1 / 3);
var tan30_2 = tan30 * 2;

// node_modules/d3-shape/src/symbol/star.js
var kr = Math.sin(pi2 / 10) / Math.sin(7 * pi2 / 10);
var kx = Math.sin(tau2 / 10) * kr;
var ky = -Math.cos(tau2 / 10) * kr;

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt3 = Math.sqrt(3);

// node_modules/d3-shape/src/symbol/wye.js
var s = Math.sqrt(3) / 2;
var k = 1 / Math.sqrt(12);
var a = (k / 2 + 1) * 3;

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/basis.js
function point(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      // proceed
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // proceed
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;
      case 3:
        this._point = 4;
      // proceed
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, j = x2.length - 1;
    if (j > 0) {
      var x0 = x2[0], y0 = y2[0], dx = x2[j] - x0, dy = y2[j] - y0, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x2[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y2[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      // proceed
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // proceed
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x2, y2) {
  var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon2) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon2) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
    y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // proceed
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // proceed
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) this._context.lineTo(x2, y2);
    else this._point = 1, this._context.moveTo(x2, y2);
  }
};

// node_modules/d3-shape/src/curve/monotone.js
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point4(that, t03, t13) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t03, x1 - dx, y1 - dx * t13, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t13 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point4(this, slope2(this, t13 = slope3(this, x2, y2)), t13);
        break;
      default:
        point4(this, this._t0, t13 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t13;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
  }
};

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n = x2.length;
    if (n) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
  a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i) a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i) m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a2[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a2[i] = (r[i] - a2[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b];
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x1 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};

// node_modules/d3-shape/src/offset/none.js
function none_default(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

// node_modules/d3-shape/src/order/none.js
function none_default2(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

// node_modules/d3-shape/src/stack.js
function stackValue(d, key) {
  return d[key];
}
function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}
function stack_default() {
  var keys = constant_default2([]), order = none_default2, offset = none_default, value = stackValue;
  function stack(data) {
    var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
    for (const d of data) {
      for (i = 0, ++j; i < n; ++i) {
        (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
      }
    }
    for (i = 0, oz = array_default(order(sz)); i < n; ++i) {
      sz[oz[i]].index = i;
    }
    offset(sz, oz);
    return sz;
  }
  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant_default2(Array.from(_)), stack) : keys;
  };
  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant_default2(+_), stack) : value;
  };
  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none_default2 : typeof _ === "function" ? _ : constant_default2(Array.from(_)), stack) : order;
  };
  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none_default : _, stack) : offset;
  };
  return stack;
}

// node_modules/react-charts/es/seriesTypes/Line.js
var import_react4 = __toESM(require_react());

// node_modules/react-charts/es/utils/curveMonotone.js
function sign2(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope32(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign2(s0) + sign2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope22(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function _point(that, t03, t13) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t03, x1 - dx, y1 - dx * t13, x1, y1);
}
function MonotoneX2(context) {
  this._context = context;
}
MonotoneX2.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        _point(this, this._t0, slope22(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point5(x2, y2) {
    var t13 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        _point(this, slope22(this, t13 = slope32(this, x2, y2)), t13);
        break;
      default:
        _point(this, this._t0, t13 = slope32(this, x2, y2));
        break;
    }
    ;
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t13;
  }
};
function MonotoneY2(context) {
  this._context = new ReflectContext2(context);
}
(MonotoneY2.prototype = Object.create(MonotoneX2.prototype)).point = function(x2, y2) {
  MonotoneX2.prototype.point.call(this, y2, x2);
};
function ReflectContext2(context) {
  this._context = context;
}
ReflectContext2.prototype = {
  moveTo: function moveTo(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function closePath() {
    this._context.closePath();
  },
  lineTo: function lineTo(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
  }
};
var monotoneX2 = function monotoneX3(context) {
  return new MonotoneX2(context);
};

// node_modules/react-charts/es/seriesTypes/Line.js
function Line(_ref) {
  var _secondaryAxis$curve;
  var primaryAxis = _ref.primaryAxis, secondaryAxis = _ref.secondaryAxis, allSeries = _ref.series;
  var _useChartContext = useChartContext(), getSeriesStatusStyle = _useChartContext.getSeriesStatusStyle, getDatumStatusStyle = _useChartContext.getDatumStatusStyle, focusedDatumState = _useChartContext.focusedDatumState, gridDimensions = _useChartContext.gridDimensions;
  var curve = (_secondaryAxis$curve = secondaryAxis.curve) != null ? _secondaryAxis$curve : monotoneX2;
  var focusedDatum = focusedDatumState[0];
  return import_react4.default.createElement("g", {
    style: {
      transform: translate(gridDimensions.left, gridDimensions.top)
    }
  }, allSeries.map(function(series, i) {
    var _lineFn, _secondaryAxis$showDa;
    var style = getSeriesStatusStyle(series, focusedDatum);
    var areaPath = null;
    if (secondaryAxis.elementType === "area") {
      var _x2 = function _x22(datum) {
        return getPrimary2(datum, primaryAxis);
      };
      var _y1 = function _y12(datum) {
        return clampPxToAxis2(getSecondaryStart2(datum, secondaryAxis), secondaryAxis);
      };
      var _y2 = function _y22(datum) {
        return clampPxToAxis2(getSecondary2(datum, secondaryAxis), secondaryAxis);
      };
      var areaFn = area_default(_x2, _y1, _y2).curve(curve);
      areaFn.defined(function(datum) {
        return [_x2(datum), _y1(datum), _y2(datum)].every(isDefined);
      });
      areaPath = areaFn(series.datums);
    }
    var _x = function _x3(datum) {
      return getPrimary2(datum, primaryAxis);
    };
    var _y = function _y3(datum) {
      return getSecondary2(datum, secondaryAxis);
    };
    var lineFn = line_default(_x, _y).curve(curve);
    lineFn.defined(function(datum) {
      return [_x(datum), _y(datum)].every(isDefined);
    });
    var linePath = secondaryAxis.elementType === "area" || secondaryAxis.elementType === "line" ? (_lineFn = lineFn(series.datums)) != null ? _lineFn : void 0 : void 0;
    var showDatumElements = (_secondaryAxis$showDa = secondaryAxis.showDatumElements) != null ? _secondaryAxis$showDa : secondaryAxis.elementType === "bubble" || "onFocus";
    return import_react4.default.createElement("g", {
      key: "lines-" + i
    }, areaPath ? import_react4.default.createElement("path", {
      d: areaPath,
      style: _extends({
        strokeWidth: 2,
        opacity: 0.5
      }, style, style.area)
    }) : null, linePath ? import_react4.default.createElement("path", {
      d: linePath,
      style: _extends({
        strokeWidth: 2
      }, style, style.line, {
        fill: "none"
      })
    }) : null, series.datums.map(function(datum, i2) {
      var _secondaryAxis$showDa2;
      var dataStyle = getDatumStatusStyle(datum, focusedDatum);
      var radius = showDatumElements === "onFocus" ? datum === focusedDatum ? 4 : 0 : 2;
      var show = showDatumElements === "onFocus" ? datum === focusedDatum : (_secondaryAxis$showDa2 = secondaryAxis.showDatumElements) != null ? _secondaryAxis$showDa2 : secondaryAxis.elementType === "bubble";
      return import_react4.default.createElement("circle", {
        key: i2,
        ref: function ref(el) {
          datum.element = el;
        },
        cx: getX(datum, primaryAxis, secondaryAxis) || 0,
        cy: getY(datum, primaryAxis, secondaryAxis) || 0,
        style: _extends({
          // @ts-ignore
          r: radius,
          transition: "all .3s ease-out"
        }, style, style.circle, dataStyle, dataStyle.circle, !show ? {
          opacity: 0
        } : {})
      });
    }));
  }));
}
function getX(datum, primaryAxis, secondaryAxis) {
  return primaryAxis.isVertical ? getSecondary2(datum, secondaryAxis) : getPrimary2(datum, primaryAxis);
}
function getY(datum, primaryAxis, secondaryAxis) {
  return primaryAxis.isVertical ? getPrimary2(datum, primaryAxis) : getSecondary2(datum, secondaryAxis);
}
function getPrimary2(datum, primaryAxis) {
  var _primaryAxis$scale;
  var primary = (_primaryAxis$scale = primaryAxis.scale(datum.primaryValue)) != null ? _primaryAxis$scale : NaN;
  if (primaryAxis.axisFamily === "band") {
    primary += primaryAxis.scale.bandwidth() / 2;
  }
  return primary;
}
function getSecondary2(datum, secondaryAxis) {
  var _secondaryAxis$scale2;
  if (secondaryAxis.stacked) {
    var _secondaryAxis$scale, _datum$stackData$, _datum$stackData;
    return (_secondaryAxis$scale = secondaryAxis.scale((_datum$stackData$ = (_datum$stackData = datum.stackData) == null ? void 0 : _datum$stackData[1]) != null ? _datum$stackData$ : NaN)) != null ? _secondaryAxis$scale : NaN;
  }
  return (_secondaryAxis$scale2 = secondaryAxis.scale(datum.secondaryValue)) != null ? _secondaryAxis$scale2 : NaN;
}
function getSecondaryStart2(datum, secondaryAxis) {
  var _secondaryAxis$scale4;
  if (secondaryAxis.stacked) {
    var _secondaryAxis$scale3, _datum$stackData$2, _datum$stackData2;
    return (_secondaryAxis$scale3 = secondaryAxis.scale((_datum$stackData$2 = (_datum$stackData2 = datum.stackData) == null ? void 0 : _datum$stackData2[0]) != null ? _datum$stackData$2 : NaN)) != null ? _secondaryAxis$scale3 : NaN;
  }
  return (_secondaryAxis$scale4 = secondaryAxis.scale(0)) != null ? _secondaryAxis$scale4 : NaN;
}
function clampPxToAxis2(px, axis) {
  var range = axis.scale.range();
  if (axis.isVertical) {
    range.reverse();
  }
  return Math.max(range[0], Math.min(px, range[1]));
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index2 = /* @__PURE__ */ new Map(), domain = [], range = [], unknown = implicit;
  function scale(d) {
    var key = d + "", i = index2.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index2.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }
  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index2 = /* @__PURE__ */ new Map();
    for (const value of _) {
      const key = value + "";
      if (index2.has(key)) continue;
      index2.set(key, domain.push(value));
    }
    return scale;
  };
  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/band.js
function band() {
  var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n = domain().length, reverse2 = r1 < r0, start = reverse2 ? r1 : r0, stop = reverse2 ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = range_default(n).map(function(i) {
      return start + step * i;
    });
    return ordinalRange(reverse2 ? values.reverse() : values);
  }
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };
  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a2) {
  if (a2 <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a2 = this.opacity;
  a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
  return (a2 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a2 === 1 ? ")" : ", " + a2 + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s2, l, a2) {
  if (a2 <= 0) h = s2 = l = NaN;
  else if (l <= 0 || l >= 1) h = s2 = NaN;
  else if (s2 <= 0) h = NaN;
  return new Hsl(h, s2, l, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min3 = Math.min(r, g, b), max3 = Math.max(r, g, b), h = NaN, s2 = max3 - min3, l = (max3 + min3) / 2;
  if (s2) {
    if (r === max3) h = (g - b) / s2 + (g < b) * 6;
    else if (g === max3) h = (b - r) / s2 + 2;
    else h = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max3 + min3 : 2 - max3 - min3;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o.opacity);
}
function hsl(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a2 = this.opacity;
    a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
    return (a2 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a2 === 1 ? ")" : ", " + a2 + ")");
  }
}));
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y2 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x2, z;
  if (r === g && g === b) x2 = z = y2;
  else {
    x2 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
}
function lab(l, a2, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a2, b, opacity == null ? 1 : opacity);
}
function Lab(l, a2, b, opacity) {
  this.l = +l;
  this.a = +a2;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter: function(k2) {
    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker: function(k2) {
    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
    x2 = Xn * lab2xyz(x2);
    y2 = Yn * lab2xyz(y2);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
      lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter: function(k2) {
    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
  },
  darker: function(k2) {
    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);
}
function cubehelix(h, s2, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a2 * (A * cosh2 + B * sinh2)),
      255 * (l + a2 * (C * cosh2 + D * sinh2)),
      255 * (l + a2 * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v2, v3) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default2(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default2(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default3 = (x2) => () => x2;

// node_modules/d3-interpolate/src/color.js
function linear(a2, d) {
  return function(t) {
    return a2 + t * d;
  };
}
function exponential(a2, b, y2) {
  return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t) {
    return Math.pow(a2 + t * b, y2);
  };
}
function hue(a2, b) {
  var d = b - a2;
  return d ? linear(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a2) ? b : a2);
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b) {
    return b - a2 ? exponential(a2, b, y2) : constant_default3(isNaN(a2) ? b : a2);
  };
}
function nogamma(a2, b) {
  var d = b - a2;
  return d ? linear(a2, d) : constant_default3(isNaN(a2) ? b : a2);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb2(start, end) {
    var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default2);
var rgbBasisClosed = rgbSpline(basisClosed_default2);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a2, b) {
  if (!b) b = [];
  var n = a2 ? Math.min(b.length, a2.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a2[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a2, b) {
  var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i) x2[i] = value_default(a2[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x2[i](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a2, b) {
  var d = /* @__PURE__ */ new Date();
  return a2 = +a2, b = +b, function(t) {
    return d.setTime(a2 * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default2(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return a2 * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a2, b) {
  var i = {}, c = {}, k2;
  if (a2 === null || typeof a2 !== "object") a2 = {};
  if (b === null || typeof b !== "object") b = {};
  for (k2 in b) {
    if (k2 in a2) {
      i[k2] = value_default(a2[k2], b[k2]);
    } else {
      c[k2] = b[k2];
    }
  }
  return function(t) {
    for (k2 in i) c[k2] = i[k2](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a2, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
  a2 = a2 + "", b = b + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s2[i]) s2[i] += bs;
      else s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i]) s2[i] += bm;
      else s2[++i] = bm;
    } else {
      s2[++i] = null;
      q.push({ i, x: number_default2(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s2[i]) s2[i] += bs;
    else s2[++i] = bs;
  }
  return s2.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s2[(o = q[i2]).i] = o.x(t);
    return s2.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a2, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant_default3(b) : (t === "number" ? number_default2 : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default2)(a2, b);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return Math.round(a2 * (1 - t) + b * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a2, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a2 * a2 + b * b)) a2 /= scaleX, b /= scaleX;
  if (skewX = a2 * c + b * d) c -= a2 * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a2 * d < b * c) a2 = -a2, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a2) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate2(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default2(xa, xb) }, { i: i - 2, x: number_default2(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a2, b, s2, q) {
    if (a2 !== b) {
      if (a2 - b > 180) b += 360;
      else if (b - a2 > 180) a2 += 360;
      q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default2(a2, b) });
    } else if (b) {
      s2.push(pop(s2) + "rotate(" + b + degParen);
    }
  }
  function skewX(a2, b, s2, q) {
    if (a2 !== b) {
      q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default2(a2, b) });
    } else if (b) {
      s2.push(pop(s2) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default2(xa, xb) }, { i: i - 2, x: number_default2(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a2, b) {
    var s2 = [], q = [];
    a2 = parse(a2), b = parse(b);
    translate2(a2.translateX, a2.translateY, b.translateX, b.translateY, s2, q);
    rotate(a2.rotate, b.rotate, s2, q);
    skewX(a2.skewX, b.skewX, s2, q);
    scale(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s2, q);
    a2 = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s2[(o = q[i]).i] = o.x(t);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon22 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon22) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s2 = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hsl(start)).h, (end = hsl(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s2(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hcl(start)).h, (end = hcl(end)).h), c = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y2) {
    y2 = +y2;
    function cubehelix3(start, end) {
      var h = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s2(t);
        start.l = l(Math.pow(t, y2));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-scale/src/constant.js
function constants(x2) {
  return function() {
    return x2;
  };
}

// node_modules/d3-scale/src/number.js
function number(x2) {
  return +x2;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity2(x2) {
  return x2;
}
function normalize(a2, b) {
  return (b -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a2, b) {
  var t;
  if (a2 > b) t = a2, a2 = b, b = t;
  return function(x2) {
    return Math.max(a2, Math.min(b, x2));
  };
}
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }
  return function(x2) {
    var i2 = bisect_default(domain, x2, 1, j) - 1;
    return r[i2](d[i2](x2));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range = unit, interpolate = value_default, transform, untransform, unknown, clamp = identity2, piecewise2, output, input;
  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity2) clamp = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain.map(transform), range, interpolate)))(transform(clamp(x2)));
  }
  scale.invert = function(y2) {
    return clamp(untransform((input || (input = piecewise2(range, domain.map(transform), number_default2)))(y2)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };
  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = round_default, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity2, rescale()) : clamp !== identity2;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity2, identity2);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p) {
  if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0) return null;
  var i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out: for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s2[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s2[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d) return x2 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d) return x2 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x2, p) => (x2 * 100).toFixed(p),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal_default,
  "e": (x2, p) => x2.toExponential(p),
  "f": (x2, p) => x2.toFixed(p),
  "g": (x2, p) => x2.toPrecision(p),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p) => formatRounded_default(x2 * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default3(x2) {
  return x2;
}

// node_modules/d3-format/src/locale.js
var map3 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale4) {
  var group2 = locale4.grouping === void 0 || locale4.thousands === void 0 ? identity_default3 : formatGroup_default(map3.call(locale4.grouping, Number), locale4.thousands + ""), currencyPrefix = locale4.currency === void 0 ? "" : locale4.currency[0] + "", currencySuffix = locale4.currency === void 0 ? "" : locale4.currency[1] + "", decimal = locale4.decimal === void 0 ? "." : locale4.decimal + "", numerals = locale4.numerals === void 0 ? identity_default3 : formatNumerals_default(map3.call(locale4.numerals, String)), percent = locale4.percent === void 0 ? "%" : locale4.percent + "", minus = locale4.minus === void 0 ? "" : locale4.minus + "", nan = locale4.nan === void 0 ? "NaN" : locale4.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero2 || fill === "0" && align === "=") zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim) value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign3 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2) value = group2(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2) value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k2 * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max3) {
  step = Math.abs(step), max3 = Math.abs(max3) - step;
  return Math.max(0, exponent_default(max3) - exponent_default(step)) + 1;
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop, count2, specifier) {
  var step = tickStep(start, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d = domain();
    return ticks_default(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null) count2 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count2);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear2() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear2());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-scale/src/nice.js
function nice2(domain, interval) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }
  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

// node_modules/d3-scale/src/log.js
function transformLog(x2) {
  return Math.log(x2);
}
function transformExp(x2) {
  return Math.exp(x2);
}
function transformLogn(x2) {
  return -Math.log(-x2);
}
function transformExpn(x2) {
  return -Math.exp(-x2);
}
function pow10(x2) {
  return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : function(x2) {
    return Math.pow(base, x2);
  };
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function(x2) {
    return Math.log(x2) / base;
  });
}
function reflect(f) {
  return function(x2) {
    return -f(-x2);
  };
}
function loggish(transform) {
  var scale = transform(transformLog, transformExp), domain = scale.domain, base = 10, logs, pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.ticks = function(count2) {
    var d = domain(), u = d[0], v = d[d.length - 1], r;
    if (r = v < u) i = u, u = v, v = i;
    var i = logs(u), j = logs(v), p, k2, t, n = count2 == null ? 10 : +count2, z = [];
    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k2 = 1, p = pows(i); k2 < base; ++k2) {
          t = p * k2;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      else for (; i <= j; ++i) {
        for (k2 = base - 1, p = pows(i); k2 >= 1; --k2) {
          t = p * k2;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = ticks_default(u, v, n);
    } else {
      z = ticks_default(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale.tickFormat = function(count2, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = format(specifier);
    if (count2 === Infinity) return specifier;
    if (count2 == null) count2 = 10;
    var k2 = Math.max(1, base * count2 / scale.ticks().length);
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k2 ? specifier(d) : "";
    };
  };
  scale.nice = function() {
    return domain(nice2(domain(), {
      floor: function(x2) {
        return pows(Math.floor(logs(x2)));
      },
      ceil: function(x2) {
        return pows(Math.ceil(logs(x2)));
      }
    }));
  };
  return scale;
}
function log() {
  var scale = loggish(transformer()).domain([1, 10]);
  scale.copy = function() {
    return copy(scale, log()).base(scale.base());
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-time/src/interval.js
var t02 = /* @__PURE__ */ new Date();
var t12 = /* @__PURE__ */ new Date();
function newInterval(floori, offseti, count2, field) {
  function interval(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval.floor = function(date2) {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval.round = function(date2) {
    var d0 = interval(date2), d1 = interval.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval.offset = function(date2, step) {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range;
    do
      range.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };
  interval.filter = function(test) {
    return newInterval(function(date2) {
      if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
    }, function(date2, step) {
      if (date2 >= date2) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date2, -1), !test(date2)) {
          }
        }
        else while (--step >= 0) {
          while (offseti(date2, 1), !test(date2)) {
          }
        }
      }
    });
  };
  if (count2) {
    interval.count = function(start, end) {
      t02.setTime(+start), t12.setTime(+end);
      floori(t02), floori(t12);
      return Math.floor(count2(t02, t12));
    };
    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function(d) {
        return field(d) % step === 0;
      } : function(d) {
        return interval.count(0, d) % step === 0;
      });
    };
  }
  return interval;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = newInterval(function() {
}, function(date2, step) {
  date2.setTime(+date2 + step);
}, function(start, end) {
  return end - start;
});
millisecond.every = function(k2) {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0)) return null;
  if (!(k2 > 1)) return millisecond;
  return newInterval(function(date2) {
    date2.setTime(Math.floor(date2 / k2) * k2);
  }, function(date2, step) {
    date2.setTime(+date2 + step * k2);
  }, function(start, end) {
    return (end - start) / k2;
  });
};
var millisecond_default = millisecond;
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds());
}, function(date2, step) {
  date2.setTime(+date2 + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date2) {
  return date2.getUTCSeconds();
});
var second_default = second;
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var minute = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date2) {
  return date2.getMinutes();
});
var minute_default = minute;
var minutes = minute.range;

// node_modules/d3-time/src/hour.js
var hour = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date2) {
  return date2.getHours();
});
var hour_default = hour;
var hours = hour.range;

// node_modules/d3-time/src/day.js
var day = newInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
var day_default = day;
var days = day.range;

// node_modules/d3-time/src/week.js
function weekday(i) {
  return newInterval(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setDate(date2.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

// node_modules/d3-time/src/month.js
var month = newInterval(function(date2) {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setMonth(date2.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date2) {
  return date2.getMonth();
});
var month_default = month;
var months = month.range;

// node_modules/d3-time/src/year.js
var year = newInterval(function(date2) {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setFullYear(date2.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date2) {
  return date2.getFullYear();
});
year.every = function(k2) {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : newInterval(function(date2) {
    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setFullYear(date2.getFullYear() + step * k2);
  });
};
var year_default = year;
var years = year.range;

// node_modules/d3-time/src/utcMinute.js
var utcMinute = newInterval(function(date2) {
  date2.setUTCSeconds(0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date2) {
  return date2.getUTCMinutes();
});
var utcMinute_default = utcMinute;
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/utcHour.js
var utcHour = newInterval(function(date2) {
  date2.setUTCMinutes(0, 0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date2) {
  return date2.getUTCHours();
});
var utcHour_default = utcHour;
var utcHours = utcHour.range;

// node_modules/d3-time/src/utcDay.js
var utcDay = newInterval(function(date2) {
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCDate(date2.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date2) {
  return date2.getUTCDate() - 1;
});
var utcDay_default = utcDay;
var utcDays = utcDay.range;

// node_modules/d3-time/src/utcWeek.js
function utcWeekday(i) {
  return newInterval(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/utcMonth.js
var utcMonth = newInterval(function(date2) {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date2) {
  return date2.getUTCMonth();
});
var utcMonth_default = utcMonth;
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/utcYear.js
var utcYear = newInterval(function(date2) {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date2) {
  return date2.getUTCFullYear();
});
utcYear.every = function(k2) {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : newInterval(function(date2) {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
  });
};
var utcYear_default = utcYear;
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year2, month2, week, day2, hour2, minute2) {
  const tickIntervals = [
    [second_default, 1, durationSecond],
    [second_default, 5, 5 * durationSecond],
    [second_default, 15, 15 * durationSecond],
    [second_default, 30, 30 * durationSecond],
    [minute2, 1, durationMinute],
    [minute2, 5, 5 * durationMinute],
    [minute2, 15, 15 * durationMinute],
    [minute2, 30, 30 * durationMinute],
    [hour2, 1, durationHour],
    [hour2, 3, 3 * durationHour],
    [hour2, 6, 6 * durationHour],
    [hour2, 12, 12 * durationHour],
    [day2, 1, durationDay],
    [day2, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month2, 1, durationMonth],
    [month2, 3, 3 * durationMonth],
    [year2, 1, durationYear]
  ];
  function ticks(start, stop, count2) {
    const reverse2 = stop < start;
    if (reverse2) [start, stop] = [stop, start];
    const interval = count2 && typeof count2.range === "function" ? count2 : tickInterval(start, stop, count2);
    const ticks2 = interval ? interval.range(start, +stop + 1) : [];
    return reverse2 ? ticks2.reverse() : ticks2;
  }
  function tickInterval(start, stop, count2) {
    const target = Math.abs(stop - start) / count2;
    const i = bisector_default(([, , step2]) => step2).right(tickIntervals, target);
    if (i === tickIntervals.length) return year2.every(tickStep(start / durationYear, stop / durationYear, count2));
    if (i === 0) return millisecond_default.every(Math.max(tickStep(start, stop, count2), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }
  return [ticks, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear_default, utcMonth_default, utcSunday, utcDay_default, utcHour_default, utcMinute_default);
var [timeTicks, timeTickInterval] = ticker(year_default, month_default, sunday, day_default, hour_default, minute_default);

// node_modules/d3-scale/node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y2, m, d) {
  return { y: y2, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale4) {
  var locale_dateTime = locale4.dateTime, locale_date = locale4.date, locale_time = locale4.time, locale_periods = locale4.periods, locale_weekdays = locale4.days, locale_shortWeekdays = locale4.shortDays, locale_months = locale4.months, locale_shortMonths = locale4.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c, pad3, format2;
      if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad3 = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad3 = c === "e" ? " " : "0";
          if (format2 = formats2[c]) c = format2(date2, pad3);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day2;
      if (i != string.length) return null;
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d)) d.Z = 0;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0) d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day2 = week.getUTCDay();
          week = day2 > 4 || day2 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay_default.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day2 = week.getDay();
          week = day2 > 4 || day2 === 0 ? monday.ceil(week) : monday(week);
          week = day_default.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m = string.length, c, parse;
    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
  var sign3 = value < 0 ? "-" : "", string = (sign3 ? -value : value) + "", length = string.length;
  return sign3 + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad(1 + day_default.count(year_default(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(year_default(d) - 1, d), p, 2);
}
function dISO(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(thursday.count(year_default(d), d) + (year_default(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad(monday.count(year_default(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay_default.count(utcYear_default(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear_default(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear_default(d), d) + (utcYear_default(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear_default(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-scale/node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-scale/node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date2) {
  return date2.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

// node_modules/d3-scale/node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  var date2 = new Date(string);
  return isNaN(date2) ? null : date2;
}
var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

// node_modules/d3-scale/src/time.js
function date(t) {
  return new Date(t);
}
function number2(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(ticks, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format2) {
  var scale = continuous(), invert = scale.invert, domain = scale.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear3 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear3)(date2);
  }
  scale.invert = function(y2) {
    return new Date(invert(y2));
  };
  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number2)) : domain().map(date);
  };
  scale.ticks = function(interval) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
  };
  scale.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale.nice = function(interval) {
    var d = domain();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
    return interval ? domain(nice2(d, interval)) : scale;
  };
  scale.copy = function() {
    return copy(scale, calendar(ticks, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format2));
  };
  return scale;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, year_default, month_default, sunday, day_default, hour_default, minute_default, second_default, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear_default, utcMonth_default, utcSunday, utcDay_default, utcHour_default, utcMinute_default, second_default, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}

// node_modules/d3-time-format/src/locale.js
function localDate2(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate2(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate2(y2, m, d) {
  return { y: y2, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale2(locale4) {
  var locale_dateTime = locale4.dateTime, locale_date = locale4.date, locale_time = locale4.time, locale_periods = locale4.periods, locale_weekdays = locale4.days, locale_shortWeekdays = locale4.shortDays, locale_months = locale4.months, locale_shortMonths = locale4.shortMonths;
  var periodRe = formatRe2(locale_periods), periodLookup = formatLookup2(locale_periods), weekdayRe = formatRe2(locale_weekdays), weekdayLookup = formatLookup2(locale_weekdays), shortWeekdayRe = formatRe2(locale_shortWeekdays), shortWeekdayLookup = formatLookup2(locale_shortWeekdays), monthRe = formatRe2(locale_months), monthLookup = formatLookup2(locale_months), shortMonthRe = formatRe2(locale_shortMonths), shortMonthLookup = formatLookup2(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth2,
    "e": formatDayOfMonth2,
    "f": formatMicroseconds2,
    "g": formatYearISO2,
    "G": formatFullYearISO2,
    "H": formatHour242,
    "I": formatHour122,
    "j": formatDayOfYear2,
    "L": formatMilliseconds2,
    "m": formatMonthNumber2,
    "M": formatMinutes2,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp2,
    "s": formatUnixTimestampSeconds2,
    "S": formatSeconds2,
    "u": formatWeekdayNumberMonday2,
    "U": formatWeekNumberSunday2,
    "V": formatWeekNumberISO2,
    "w": formatWeekdayNumberSunday2,
    "W": formatWeekNumberMonday2,
    "x": null,
    "X": null,
    "y": formatYear2,
    "Y": formatFullYear2,
    "Z": formatZone2,
    "%": formatLiteralPercent2
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth2,
    "e": formatUTCDayOfMonth2,
    "f": formatUTCMicroseconds2,
    "g": formatUTCYearISO2,
    "G": formatUTCFullYearISO2,
    "H": formatUTCHour242,
    "I": formatUTCHour122,
    "j": formatUTCDayOfYear2,
    "L": formatUTCMilliseconds2,
    "m": formatUTCMonthNumber2,
    "M": formatUTCMinutes2,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp2,
    "s": formatUnixTimestampSeconds2,
    "S": formatUTCSeconds2,
    "u": formatUTCWeekdayNumberMonday2,
    "U": formatUTCWeekNumberSunday2,
    "V": formatUTCWeekNumberISO2,
    "w": formatUTCWeekdayNumberSunday2,
    "W": formatUTCWeekNumberMonday2,
    "x": null,
    "X": null,
    "y": formatUTCYear2,
    "Y": formatUTCFullYear2,
    "Z": formatUTCZone2,
    "%": formatLiteralPercent2
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth2,
    "e": parseDayOfMonth2,
    "f": parseMicroseconds2,
    "g": parseYear2,
    "G": parseFullYear2,
    "H": parseHour242,
    "I": parseHour242,
    "j": parseDayOfYear2,
    "L": parseMilliseconds2,
    "m": parseMonthNumber2,
    "M": parseMinutes2,
    "p": parsePeriod,
    "q": parseQuarter2,
    "Q": parseUnixTimestamp2,
    "s": parseUnixTimestampSeconds2,
    "S": parseSeconds2,
    "u": parseWeekdayNumberMonday2,
    "U": parseWeekNumberSunday2,
    "V": parseWeekNumberISO2,
    "w": parseWeekdayNumberSunday2,
    "W": parseWeekNumberMonday2,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear2,
    "Y": parseFullYear2,
    "Z": parseZone2,
    "%": parseLiteralPercent2
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c, pad3, format2;
      if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad3 = pads2[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad3 = c === "e" ? " " : "0";
          if (format2 = formats2[c]) c = format2(date2, pad3);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate2(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day2;
      if (i != string.length) return null;
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d)) d.Z = 0;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0) d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate2(newDate2(d.y, 0, 1)), day2 = week.getUTCDay();
          week = day2 > 4 || day2 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay_default.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate2(newDate2(d.y, 0, 1)), day2 = week.getDay();
          week = day2 > 4 || day2 === 0 ? monday.ceil(week) : monday(week);
          week = day_default.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate2(newDate2(d.y, 0, 1)).getUTCDay() : localDate2(newDate2(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate2(d);
      }
      return localDate2(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m = string.length, c, parse;
    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads2 ? specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads2 = { "-": "", "_": " ", "0": "0" };
var numberRe2 = /^\s*\d+/;
var percentRe2 = /^%/;
var requoteRe2 = /[\\^$*+?|[\]().{}]/g;
function pad2(value, fill, width) {
  var sign3 = value < 0 ? "-" : "", string = (sign3 ? -value : value) + "", length = string.length;
  return sign3 + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote2(s2) {
  return s2.replace(requoteRe2, "\\$&");
}
function formatRe2(names) {
  return new RegExp("^(?:" + names.map(requote2).join("|") + ")", "i");
}
function formatLookup2(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone2(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour242(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent2(d, string, i) {
  var n = percentRe2.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp2(d, string, i) {
  var n = numberRe2.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds2(d, string, i) {
  var n = numberRe2.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth2(d, p) {
  return pad2(d.getDate(), p, 2);
}
function formatHour242(d, p) {
  return pad2(d.getHours(), p, 2);
}
function formatHour122(d, p) {
  return pad2(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear2(d, p) {
  return pad2(1 + day_default.count(year_default(d), d), p, 3);
}
function formatMilliseconds2(d, p) {
  return pad2(d.getMilliseconds(), p, 3);
}
function formatMicroseconds2(d, p) {
  return formatMilliseconds2(d, p) + "000";
}
function formatMonthNumber2(d, p) {
  return pad2(d.getMonth() + 1, p, 2);
}
function formatMinutes2(d, p) {
  return pad2(d.getMinutes(), p, 2);
}
function formatSeconds2(d, p) {
  return pad2(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday2(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday2(d, p) {
  return pad2(sunday.count(year_default(d) - 1, d), p, 2);
}
function dISO2(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO2(d, p) {
  d = dISO2(d);
  return pad2(thursday.count(year_default(d), d) + (year_default(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday2(d) {
  return d.getDay();
}
function formatWeekNumberMonday2(d, p) {
  return pad2(monday.count(year_default(d) - 1, d), p, 2);
}
function formatYear2(d, p) {
  return pad2(d.getFullYear() % 100, p, 2);
}
function formatYearISO2(d, p) {
  d = dISO2(d);
  return pad2(d.getFullYear() % 100, p, 2);
}
function formatFullYear2(d, p) {
  return pad2(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO2(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad2(d.getFullYear() % 1e4, p, 4);
}
function formatZone2(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad2(z / 60 | 0, "0", 2) + pad2(z % 60, "0", 2);
}
function formatUTCDayOfMonth2(d, p) {
  return pad2(d.getUTCDate(), p, 2);
}
function formatUTCHour242(d, p) {
  return pad2(d.getUTCHours(), p, 2);
}
function formatUTCHour122(d, p) {
  return pad2(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear2(d, p) {
  return pad2(1 + utcDay_default.count(utcYear_default(d), d), p, 3);
}
function formatUTCMilliseconds2(d, p) {
  return pad2(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds2(d, p) {
  return formatUTCMilliseconds2(d, p) + "000";
}
function formatUTCMonthNumber2(d, p) {
  return pad2(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes2(d, p) {
  return pad2(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds2(d, p) {
  return pad2(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday2(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday2(d, p) {
  return pad2(utcSunday.count(utcYear_default(d) - 1, d), p, 2);
}
function UTCdISO2(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO2(d, p) {
  d = UTCdISO2(d);
  return pad2(utcThursday.count(utcYear_default(d), d) + (utcYear_default(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday2(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday2(d, p) {
  return pad2(utcMonday.count(utcYear_default(d) - 1, d), p, 2);
}
function formatUTCYear2(d, p) {
  return pad2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO2(d, p) {
  d = UTCdISO2(d);
  return pad2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear2(d, p) {
  return pad2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO2(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone2() {
  return "+0000";
}
function formatLiteralPercent2() {
  return "%";
}
function formatUnixTimestamp2(d) {
  return +d;
}
function formatUnixTimestampSeconds2(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale3;
var timeFormat2;
var timeParse2;
var utcFormat2;
var utcParse2;
defaultLocale3({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale3(definition) {
  locale3 = formatLocale2(definition);
  timeFormat2 = locale3.format;
  timeParse2 = locale3.parse;
  utcFormat2 = locale3.utcFormat;
  utcParse2 = locale3.utcParse;
  return locale3;
}

// node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier2 = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative2(date2) {
  return date2.toISOString();
}
var formatIso2 = Date.prototype.toISOString ? formatIsoNative2 : utcFormat2(isoSpecifier2);

// node_modules/d3-time-format/src/isoParse.js
function parseIsoNative2(string) {
  var date2 = new Date(string);
  return isNaN(date2) ? null : date2;
}
var parseIso2 = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative2 : utcParse2(isoSpecifier2);

// node_modules/react-charts/es/utils/buildAxis.linear.js
function defaultAxisOptions(options) {
  var _options$elementType, _options$minTickPaddi, _options$tickLabelRot, _options$innerBandPad, _options$outerBandPad, _options$innerSeriesB, _options$outerSeriesB, _options$show, _options$stacked, _options$shouldNice;
  return _extends({}, options, {
    elementType: (_options$elementType = options.elementType) != null ? _options$elementType : "line",
    minTickPaddingForRotation: (_options$minTickPaddi = options.minTickPaddingForRotation) != null ? _options$minTickPaddi : 10,
    tickLabelRotationDeg: (_options$tickLabelRot = options.tickLabelRotationDeg) != null ? _options$tickLabelRot : 60,
    innerBandPadding: (_options$innerBandPad = options.innerBandPadding) != null ? _options$innerBandPad : 0.5,
    outerBandPadding: (_options$outerBandPad = options.outerBandPadding) != null ? _options$outerBandPad : 0.2,
    innerSeriesBandPadding: (_options$innerSeriesB = options.innerSeriesBandPadding) != null ? _options$innerSeriesB : 0.2,
    outerSeriesBandPadding: (_options$outerSeriesB = options.outerSeriesBandPadding) != null ? _options$outerSeriesB : 0,
    show: (_options$show = options.show) != null ? _options$show : true,
    stacked: (_options$stacked = options.stacked) != null ? _options$stacked : false,
    shouldNice: (_options$shouldNice = options.shouldNice) != null ? _options$shouldNice : true
  });
}
function buildAxisLinear(isPrimary, userOptions, series, allDatums, gridDimensions, width, height) {
  var options = defaultAxisOptions(userOptions);
  if (!options.position) {
    throw new Error("Chart axes must have a valid 'position' property");
  }
  var isVertical = ["left", "right"].indexOf(options.position) > -1;
  var range = isVertical ? [gridDimensions.height, 0] : [0, gridDimensions.width];
  var outerRange = isVertical ? [height, 0] : [0, width];
  return options.scaleType === "time" || options.scaleType === "localTime" ? buildTimeAxis(isPrimary, options, series, allDatums, isVertical, range, outerRange) : options.scaleType === "linear" || options.scaleType === "log" ? buildLinearAxis(isPrimary, options, series, allDatums, isVertical, range, outerRange) : options.scaleType === "band" ? buildBandAxis(isPrimary, options, series, isVertical, range, outerRange) : function() {
    throw new Error("Invalid scale type");
  }();
}
function buildTimeAxis(isPrimary, options, series, allDatums, isVertical, range, outerRange) {
  var isLocal = options.scaleType === "localTime";
  var scaleFn = isLocal ? time : utcTime;
  var isInvalid = false;
  series = isPrimary ? series : series.filter(function(s2) {
    return s2.secondaryAxisId === options.id;
  });
  allDatums = isPrimary ? allDatums : allDatums.filter(function(d) {
    return d.secondaryAxisId === options.id;
  });
  var scale = scaleFn(range);
  var _extent = extent_default(allDatums, function(datum) {
    var value = options.getValue(datum.originalDatum);
    datum[isPrimary ? "primaryValue" : "secondaryValue"] = value;
    return value;
  }), minValue = _extent[0], maxValue = _extent[1];
  var autoFormatStr;
  var units = isLocal ? {
    year: year_default,
    month: month_default,
    day: day_default,
    hour: hour_default,
    minute: minute_default,
    second: second_default
  } : {
    year: utcYear_default,
    month: utcMonth_default,
    day: utcDay_default,
    hour: utcHour_default,
    minute: utcMinute_default,
    second: second_default
  };
  if (minValue && maxValue) {
    if (units.year.count(minValue, maxValue) > 0 || units.year.floor(maxValue) < units.year()) {
      autoFormatStr = "%b %-d, %Y %-I:%M:%S.%L %p";
    } else if (units.month.count(minValue, maxValue) > 0 || units.month.floor(maxValue) < units.month()) {
      autoFormatStr = "%b %-d, %-I:%M:%S.%L %p";
    } else if (units.day.count(minValue, maxValue) > 0 || units.day.floor(maxValue) < units.day()) {
      autoFormatStr = "%b %-d, %-I:%M:%S.%L %p";
    } else if (units.hour.count(minValue, maxValue) > 0 || units.hour.floor(maxValue) < units.hour()) {
      autoFormatStr = "%-I:%M:%S.%L %p";
    } else if (units.minute.count(minValue, maxValue) > 0 || units.minute.floor(maxValue) < units.minute()) {
      autoFormatStr = "%-I:%M:%S.%L";
    } else if (units.second.count(minValue, maxValue) > 0 || units.second.floor(maxValue) < units.second()) {
      autoFormatStr = "%L";
    }
  }
  var resolvedTimeFormat = isLocal ? timeFormat2 : utcFormat2;
  var trimFormat = function trimFormat2(str) {
    return str.trim().replace(/(,$|^,)/, "");
  };
  var contextFormat = function contextFormat2(format2, date2) {
    if (units.second(date2) < date2) {
      return resolvedTimeFormat(format2)(date2);
    }
    if (units.minute(date2) < date2) {
      return resolvedTimeFormat(trimFormat(format2.replace(/\.%L.*?(\s|$)/, "")))(date2);
    }
    if (units.hour(date2) < date2) {
      return resolvedTimeFormat(trimFormat(format2.replace(/:%S.*?(\s|$)/, "")))(date2);
    }
    if (units.day(date2) < date2) {
      return resolvedTimeFormat(trimFormat(format2.replace(/:%M.*?(\s|$)/, "")))(date2);
    }
    if (units.month(date2) < date2) {
      return resolvedTimeFormat(trimFormat(format2.replace(/%-I.*/, "")))(date2);
    }
    if (units.year(date2) < date2) {
      return resolvedTimeFormat(trimFormat(format2.replace(/%-d.*/, "")))(date2);
    }
    return resolvedTimeFormat("%Y")(date2);
  };
  var shouldNice = options.shouldNice;
  if (Object.prototype.toString.call(options.min) === "[object Date]") {
    minValue = min([options.min, minValue]);
    shouldNice = false;
  }
  if (Object.prototype.toString.call(options.max) === "[object Date]") {
    maxValue = max([options.max, maxValue]);
    shouldNice = false;
  }
  if (Object.prototype.toString.call(options.hardMin) === "[object Date]") {
    minValue = options.hardMin;
    shouldNice = false;
  }
  if (Object.prototype.toString.call(options.hardMax) === "[object Date]") {
    maxValue = options.hardMax;
    shouldNice = false;
  }
  if (minValue === void 0 || maxValue === void 0) {
    console.info("Invalid scale min/max", {
      options,
      series,
      range,
      values: allDatums.map(function(d) {
        return isPrimary ? d.primaryValue : d.secondaryValue;
      })
    });
    isInvalid = true;
  }
  scale.domain([minValue, maxValue]);
  if (options.invert) {
    scale.domain(Array.from(scale.domain()).reverse());
  }
  if (shouldNice) {
    scale.nice();
  }
  var outerScale = scale.copy().range(outerRange);
  var primaryBandScale = isPrimary ? buildPrimaryBandScale(options, scale, series, range) : void 0;
  var seriesBandScale = primaryBandScale ? buildSeriesBandScale(options, primaryBandScale, series) : void 0;
  var primaryBandWidth = primaryBandScale == null ? void 0 : primaryBandScale.bandwidth();
  if (options.padBandRange && primaryBandWidth) {
    var bandStart = scale.invert(0);
    var bandEnd = scale.invert(primaryBandWidth);
    var diff = bandEnd.valueOf() - bandStart.valueOf();
    scale.domain([new Date(scale.domain()[0].valueOf() - diff / 2), new Date(scale.domain()[1].valueOf() + diff / 2)]);
  }
  var formatters = {};
  var defaultFormat = scale.tickFormat();
  var scaleFormat = function scaleFormat2(value) {
    var _options$formatters$s, _options$formatters;
    return (_options$formatters$s = (_options$formatters = options.formatters) == null ? void 0 : _options$formatters.scale == null ? void 0 : _options$formatters.scale(value, _extends({}, formatters, {
      scale: void 0
    }))) != null ? _options$formatters$s : contextFormat(autoFormatStr, value);
  };
  var tooltipFormat = function tooltipFormat2(value) {
    var _options$formatters$t, _options$formatters2;
    return (_options$formatters$t = (_options$formatters2 = options.formatters) == null ? void 0 : _options$formatters2.tooltip == null ? void 0 : _options$formatters2.tooltip(value, _extends({}, formatters, {
      tooltip: void 0
    }))) != null ? _options$formatters$t : scaleFormat(value);
  };
  var cursorFormat = function cursorFormat2(value) {
    var _options$formatters$c, _options$formatters3;
    return (_options$formatters$c = (_options$formatters3 = options.formatters) == null ? void 0 : _options$formatters3.cursor == null ? void 0 : _options$formatters3.cursor(value, _extends({}, formatters, {
      cursor: void 0
    }))) != null ? _options$formatters$c : scaleFormat(value);
  };
  Object.assign(formatters, {
    "default": defaultFormat,
    scale: scaleFormat,
    tooltip: tooltipFormat,
    cursor: cursorFormat
  });
  return _extends({}, options, {
    isInvalid,
    axisFamily: "time",
    isVertical,
    scale,
    range,
    outerScale,
    primaryBandScale,
    seriesBandScale,
    formatters
  });
}
function buildLinearAxis(isPrimary, options, series, allDatums, isVertical, range, outerRange) {
  var scale = options.scaleType === "log" ? log() : linear2();
  var isInvalid = false;
  series = isPrimary ? series : series.filter(function(s2) {
    return s2.secondaryAxisId === options.id;
  });
  allDatums = isPrimary ? allDatums : allDatums.filter(function(d) {
    return d.secondaryAxisId === options.id;
  });
  if (options.stacked) {
    stackSeries2(series, options);
  }
  var _ref = options.stacked ? extent_default(series.map(function(s2) {
    return s2.datums.map(function(datum) {
      var _datum$stackData;
      var value = options.getValue(datum.originalDatum);
      datum[isPrimary ? "primaryValue" : "secondaryValue"] = value;
      return (_datum$stackData = datum.stackData) != null ? _datum$stackData : [];
    });
  }).flat(2)) : extent_default(allDatums, function(datum) {
    var value = options.getValue(datum.originalDatum);
    datum[isPrimary ? "primaryValue" : "secondaryValue"] = value;
    return value;
  }), minValue = _ref[0], maxValue = _ref[1];
  var shouldNice = options.shouldNice;
  if (typeof options.min === "number") {
    minValue = min([options.min, minValue]);
    shouldNice = false;
  }
  if (typeof options.max === "number") {
    maxValue = max([options.max, maxValue]);
    shouldNice = false;
  }
  if (typeof options.minDomainLength === "number" && !(minValue === void 0 || maxValue === void 0)) {
    var mid = median_default([minValue, maxValue]);
    var top = mid + options.minDomainLength / 2;
    var bottom = mid - options.minDomainLength / 2;
    maxValue = Math.max(top, maxValue);
    minValue = Math.min(bottom, minValue);
  }
  if (typeof options.hardMin === "number") {
    minValue = options.hardMin;
    shouldNice = false;
  }
  if (typeof options.hardMax === "number") {
    maxValue = options.hardMax;
    shouldNice = false;
  }
  if (minValue === void 0 || maxValue === void 0) {
    var _minValue, _maxValue;
    isInvalid = true;
    console.info("Invalid scale min/max", {
      options,
      series,
      range,
      values: allDatums.map(function(d) {
        return isPrimary ? d.primaryValue : d.secondaryValue;
      })
    });
    minValue = (_minValue = minValue) != null ? _minValue : 0;
    maxValue = (_maxValue = maxValue) != null ? _maxValue : 0;
  }
  scale.domain([minValue, maxValue]);
  if (options.invert) {
    scale.domain(Array.from(scale.domain()).reverse());
  }
  scale.range(range);
  if (shouldNice) {
    scale.nice();
  }
  var outerScale = scale.copy().range(outerRange);
  var primaryBandScale = isPrimary ? buildPrimaryBandScale(options, scale, series, range) : void 0;
  var seriesBandScale = primaryBandScale ? buildSeriesBandScale(options, primaryBandScale, series) : void 0;
  var defaultFormat = scale.tickFormat();
  var formatters = {};
  var scaleFormat = function scaleFormat2(value) {
    var _options$formatters$s2, _options$formatters4;
    return (_options$formatters$s2 = (_options$formatters4 = options.formatters) == null ? void 0 : _options$formatters4.scale == null ? void 0 : _options$formatters4.scale(value, _extends({}, formatters, {
      scale: void 0
    }))) != null ? _options$formatters$s2 : defaultFormat(value);
  };
  var tooltipFormat = function tooltipFormat2(value) {
    var _options$formatters$t2, _options$formatters5;
    return (_options$formatters$t2 = (_options$formatters5 = options.formatters) == null ? void 0 : _options$formatters5.tooltip == null ? void 0 : _options$formatters5.tooltip(value, _extends({}, formatters, {
      tooltip: void 0
    }))) != null ? _options$formatters$t2 : scaleFormat(value);
  };
  var cursorFormat = function cursorFormat2(value) {
    var _options$formatters$c2, _options$formatters6;
    return (_options$formatters$c2 = (_options$formatters6 = options.formatters) == null ? void 0 : _options$formatters6.cursor == null ? void 0 : _options$formatters6.cursor(value, _extends({}, formatters, {
      cursor: void 0
    }))) != null ? _options$formatters$c2 : tooltipFormat(value);
  };
  Object.assign(formatters, {
    "default": defaultFormat,
    scale: scaleFormat,
    tooltip: tooltipFormat,
    cursor: cursorFormat
  });
  return _extends({}, options, {
    isInvalid,
    axisFamily: "linear",
    isVertical,
    scale,
    range,
    outerScale,
    primaryBandScale,
    seriesBandScale,
    formatters
  });
}
function buildBandAxis(isPrimary, options, series, isVertical, range, outerRange) {
  var _options$outerBandPad2, _options$innerBandPad2;
  series = series.filter(function(d) {
    return d.secondaryAxisId === options.id;
  });
  var isInvalid = false;
  var domain = Array.from(new Set(series.map(function(d) {
    return d.datums;
  }).flat().map(function(datum) {
    var value = options.getValue(datum.originalDatum);
    datum[isPrimary ? "primaryValue" : "secondaryValue"] = value;
    return value;
  })));
  var scale = band(domain, range).round(false).paddingOuter((_options$outerBandPad2 = options.outerBandPadding) != null ? _options$outerBandPad2 : 0).paddingInner((_options$innerBandPad2 = options.innerBandPadding) != null ? _options$innerBandPad2 : 0);
  if (options.invert) {
    scale.domain(Array.from(scale.domain()).reverse());
  }
  var outerScale = scale.copy().range(outerRange);
  var primaryBandScale = scale;
  var seriesBandScale = buildSeriesBandScale(options, primaryBandScale, series);
  var defaultFormat = function defaultFormat2(d) {
    return d;
  };
  var formatters = {};
  var scaleFormat = function scaleFormat2(value) {
    var _options$formatters$s3, _options$formatters7;
    return (_options$formatters$s3 = (_options$formatters7 = options.formatters) == null ? void 0 : _options$formatters7.scale == null ? void 0 : _options$formatters7.scale(value, _extends({}, formatters, {
      scale: void 0
    }))) != null ? _options$formatters$s3 : defaultFormat(value);
  };
  var tooltipFormat = function tooltipFormat2(value) {
    var _options$formatters$t3, _options$formatters8;
    return (_options$formatters$t3 = (_options$formatters8 = options.formatters) == null ? void 0 : _options$formatters8.tooltip == null ? void 0 : _options$formatters8.tooltip(value, _extends({}, formatters, {
      tooltip: void 0
    }))) != null ? _options$formatters$t3 : scaleFormat(value);
  };
  var cursorFormat = function cursorFormat2(value) {
    var _options$formatters$c3, _options$formatters9;
    return (_options$formatters$c3 = (_options$formatters9 = options.formatters) == null ? void 0 : _options$formatters9.cursor == null ? void 0 : _options$formatters9.cursor(value, _extends({}, formatters, {
      cursor: void 0
    }))) != null ? _options$formatters$c3 : tooltipFormat(value);
  };
  Object.assign(formatters, {
    "default": defaultFormat,
    scale: scaleFormat,
    tooltip: tooltipFormat,
    cursor: cursorFormat
  });
  return _extends({}, options, {
    isInvalid,
    axisFamily: "band",
    isVertical,
    scale,
    range,
    outerScale,
    formatters,
    primaryBandScale,
    seriesBandScale
  });
}
function stackSeries2(series, axisOptions) {
  var _axisOptions$stackOff;
  var seriesIndices = Object.keys(series);
  var stacker = stack_default().keys(seriesIndices).value(function(_, seriesIndex, index2) {
    var _series$Number, _series$Number$datums;
    var originalDatum = (_series$Number = series[Number(seriesIndex)]) == null ? void 0 : (_series$Number$datums = _series$Number.datums[index2]) == null ? void 0 : _series$Number$datums.originalDatum;
    var val = typeof originalDatum !== "undefined" ? axisOptions.getValue(originalDatum) : 0;
    if (typeof val === "undefined" || val === null) {
      return 0;
    }
    return val;
  }).offset((_axisOptions$stackOff = axisOptions.stackOffset) != null ? _axisOptions$stackOff : none_default);
  var stacked = stacker(Array.from({
    length: series.sort(function(a2, b) {
      return b.datums.length - a2.datums.length;
    })[0].datums.length
  }));
  for (var sIndex = 0; sIndex < stacked.length; sIndex++) {
    var s2 = stacked[sIndex];
    for (var i = 0; i < s2.length; i++) {
      var datum = s2[i];
      if (series[sIndex].datums[i]) {
        datum.data = series[sIndex].datums[i];
        series[sIndex].datums[i].stackData = datum;
      }
    }
  }
}
function buildPrimaryBandScale(options, scale, series, range) {
  var _options$outerBandPad3, _options$innerBandPad3;
  var impliedBandWidth = Math.max.apply(Math, range);
  var bandRange = Math.max.apply(Math, range);
  (function() {
    for (var i = 0; i < series.length; i++) {
      var serie = series[i];
      for (var j = 0; j < serie.datums.length; j++) {
        var _d1$primaryValue;
        var d1 = serie.datums[j];
        var one2 = scale((_d1$primaryValue = d1.primaryValue) != null ? _d1$primaryValue : NaN);
        for (var k2 = 0; k2 < serie.datums.length; k2++) {
          var _d2$primaryValue;
          var d2 = serie.datums[k2];
          var two = scale((_d2$primaryValue = d2.primaryValue) != null ? _d2$primaryValue : NaN);
          if (one2 === two) {
            continue;
          }
          var diff = Math.abs(Math.max(one2, two) - Math.min(one2, two));
          if (diff < impliedBandWidth) {
            impliedBandWidth = Math.max(diff, bandRange);
            if (impliedBandWidth === bandRange) {
              return;
            }
          }
        }
      }
    }
  })();
  var bandDomain = range_default(bandRange / impliedBandWidth);
  var primaryBandScale = band(bandDomain, range).round(false).paddingOuter((_options$outerBandPad3 = options.outerBandPadding) != null ? _options$outerBandPad3 : 0).paddingInner((_options$innerBandPad3 = options.innerBandPadding) != null ? _options$innerBandPad3 : 0);
  return primaryBandScale;
}
function buildSeriesBandScale(options, primaryBandScale, series) {
  var _options$outerSeriesB2, _options$innerSeriesB2;
  var bandDomain = range_default(series.length);
  var seriesBandScale = band(bandDomain, [0, primaryBandScale.bandwidth()]).round(false).paddingOuter((_options$outerSeriesB2 = options.outerSeriesBandPadding) != null ? _options$outerSeriesB2 : options.outerBandPadding ? options.outerBandPadding / 2 : 0).paddingInner((_options$innerSeriesB2 = options.innerSeriesBandPadding) != null ? _options$innerSeriesB2 : options.innerBandPadding ? options.innerBandPadding / 2 : 0);
  var scale = function scale2(seriesIndex) {
    var _series$find;
    return seriesBandScale((_series$find = series.find(function(d) {
      return d.index === seriesIndex;
    })) == null ? void 0 : _series$find.indexPerAxis);
  };
  return Object.assign(scale, seriesBandScale);
}

// node_modules/react-charts/es/components/AxisLinear.js
var import_react6 = __toESM(require_react());

// node_modules/react-charts/es/components/AxisLinear.useMeasure.js
var import_react5 = __toESM(require_react());
var getElBox = function getElBox2(el) {
  var rect = el.getBoundingClientRect();
  return {
    top: Math.round(rect.top),
    right: Math.round(rect.right),
    bottom: Math.round(rect.bottom),
    left: Math.round(rect.left),
    width: Math.round(rect.width),
    height: Math.round(rect.height),
    x: Math.round(rect.x),
    y: Math.round(rect.y)
  };
};
function useMeasure(_ref) {
  var axis = _ref.axis, elRef = _ref.elRef, gridDimensions = _ref.gridDimensions, setShowRotated = _ref.setShowRotated;
  var _useChartContext = useChartContext(), axisDimensionsState = _useChartContext.axisDimensionsState;
  var axisDimensions = axisDimensionsState[0], setAxisDimensions = axisDimensionsState[1];
  var axisDimension = import_react5.default.useMemo(function() {
    var _axisDimensions;
    return (_axisDimensions = axisDimensions[axis.position]) == null ? void 0 : _axisDimensions[axis.id];
  }, [axisDimensions, axis.position, axis.id]);
  var measureRotation = import_react5.default.useCallback(function() {
    var _widestLabel2;
    if (!elRef.current) {
      return;
    }
    var gridSize = !axis.isVertical ? gridDimensions.width : gridDimensions.height;
    var staticLabelDims = Array.from(elRef.current.querySelectorAll(".Axis-Group.outer .tickLabel")).map(function(el) {
      return getElBox(el);
    });
    var widestLabel;
    staticLabelDims.forEach(function(label) {
      var _widestLabel;
      var resolvedLabel = (_widestLabel = widestLabel) != null ? _widestLabel : {
        width: 0
      };
      if (label.width > 0 && label.width > resolvedLabel.width) {
        widestLabel = label;
      }
    });
    var smallestTickGap = gridSize;
    if (staticLabelDims.length > 1) {
      staticLabelDims.forEach(function(current, i) {
        var prev = staticLabelDims[i - 1];
        if (prev) {
          smallestTickGap = Math.min(smallestTickGap, axis.isVertical ? current.top - prev.top : current.left - prev.left);
        }
      });
    }
    var shouldRotate = (((_widestLabel2 = widestLabel) == null ? void 0 : _widestLabel2.width) || 0) + axis.minTickPaddingForRotation > smallestTickGap;
    if (!axis.isVertical) {
      setShowRotated(shouldRotate);
    }
  }, [elRef, axis.isVertical, axis.minTickPaddingForRotation, gridDimensions.width, gridDimensions.height, setShowRotated]);
  var measureDimensions = import_react5.default.useCallback(function() {
    if (!elRef.current) {
      if (axisDimension) {
        setAxisDimensions(function(old) {
          var _old$axis$position, _extends2;
          var newAxes = _extends({}, (_old$axis$position = old[axis.position]) != null ? _old$axis$position : {});
          delete newAxes[axis.id];
          return _extends({}, old, (_extends2 = {}, _extends2[axis.position] = newAxes, _extends2));
        });
      }
      return;
    }
    var newDimensions = {
      width: 0,
      height: 0,
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    };
    var currentEl = elRef.current;
    var axisEl = currentEl.querySelector(".Axis-Group.inner .domainAndTicks");
    var domainEl = currentEl.querySelector(".Axis-Group.inner .domain");
    if (!axisEl || !domainEl) {
      return;
    }
    var axisDims = getElBox(axisEl);
    var domainDims = getElBox(domainEl);
    if (!axisDims || !domainDims) {
      return;
    }
    if (!axis.isVertical) {
      newDimensions.paddingLeft = Math.round(Math.max(0, domainDims.left - (axisDims == null ? void 0 : axisDims.left)));
      newDimensions.paddingRight = Math.round(Math.max(0, (axisDims == null ? void 0 : axisDims.right) - domainDims.right));
      newDimensions.height = axisDims == null ? void 0 : axisDims.height;
    } else {
      newDimensions.paddingTop = Math.round(Math.max(0, domainDims.top - (axisDims == null ? void 0 : axisDims.top)));
      newDimensions.paddingBottom = Math.round(Math.max(0, (axisDims == null ? void 0 : axisDims.bottom) - domainDims.bottom));
      newDimensions.width = axisDims == null ? void 0 : axisDims.width;
    }
    if (
      // !isLooping &&
      !axisDimensions || !axisDimension || Object.keys(newDimensions).some(function(key) {
        return newDimensions[key] !== axisDimension[key];
      })
    ) {
      setAxisDimensions(function(old) {
        var _old$axis$position2, _extends3, _extends4;
        return _extends({}, old, (_extends4 = {}, _extends4[axis.position] = _extends({}, (_old$axis$position2 = old[axis.position]) != null ? _old$axis$position2 : {}, (_extends3 = {}, _extends3[axis.id] = newDimensions, _extends3)), _extends4));
      });
    }
  }, [axis.id, axis.isVertical, axis.position, axisDimension, axisDimensions, elRef, setAxisDimensions]);
  useIsomorphicLayoutEffect_default(function() {
    window.requestAnimationFrame(function() {
      measureRotation();
      measureDimensions();
    });
  }, [measureRotation]);
}

// node_modules/react-charts/es/components/AxisLinear.js
function AxisLinearComp(axis) {
  var _React$useState = import_react6.default.useState(false), showRotated = _React$useState[0], setShowRotated = _React$useState[1];
  var _useChartContext = useChartContext(), getOptions = _useChartContext.getOptions, gridDimensions = _useChartContext.gridDimensions, width = _useChartContext.width, height = _useChartContext.height;
  var _getOptions = getOptions(), dark = _getOptions.dark, showDebugAxes = _getOptions.showDebugAxes;
  var elRef = import_react6.default.useRef(null);
  useMeasure({
    axis,
    elRef,
    gridDimensions,
    showRotated,
    setShowRotated
  });
  var renderAxis = function renderAxis2(isOuter) {
    var isRotated = !isOuter && showRotated;
    var scale = isOuter ? axis.outerScale : axis.scale;
    var _scale$range = scale.range(), rangeStart = _scale$range[0], rangeEnd = _scale$range[1];
    var getTicks = function getTicks2() {
      var anyAxis = axis;
      if (anyAxis.outerScale.ticks) {
        if (typeof anyAxis.tickCount === "number") {
          return anyAxis.outerScale.ticks(anyAxis.tickCount);
        }
        var autoSpacing = anyAxis.isVertical ? 40 : 80;
        var range = anyAxis.outerScale.range();
        var num = Math.abs(range[1] - range[0]) / autoSpacing;
        return anyAxis.outerScale.ticks(num);
      }
      return anyAxis.outerScale.domain();
    };
    var resolvedHeight = isOuter ? height : gridDimensions.height;
    var resolvedWidth = isOuter ? width : gridDimensions.width;
    var _ref = axis.position === "left" ? [{
      x: 0,
      y: rangeStart
    }, {
      x: 0,
      y: rangeEnd
    }] : axis.position === "right" ? [{
      x: resolvedWidth,
      y: rangeStart
    }, {
      x: resolvedWidth,
      y: rangeEnd
    }] : axis.position === "top" ? [{
      x: rangeStart,
      y: 0
    }, {
      x: rangeEnd,
      y: 0
    }] : [{
      x: rangeStart,
      y: resolvedHeight
    }, {
      x: rangeEnd,
      y: resolvedHeight
    }], lineFrom = _ref[0], lineTo2 = _ref[1];
    var ticks = getTicks().map(function(tick) {
      var px = getTickPx(scale, tick);
      var _ref2 = axis.position === "left" ? [{
        x: 0,
        y: px
      }, {
        x: -8,
        y: px
      }, {
        x: resolvedWidth,
        y: px
      }] : axis.position === "right" ? [{
        x: resolvedWidth,
        y: px
      }, {
        x: resolvedWidth + 8,
        y: px
      }, {
        x: 0,
        y: px
      }] : axis.position === "top" ? [{
        x: px,
        y: 0
      }, {
        x: px,
        y: -8
      }, {
        x: px,
        y: resolvedHeight
      }] : [{
        x: px,
        y: resolvedHeight
      }, {
        x: px,
        y: resolvedHeight + 8
      }, {
        x: px,
        y: 0
      }], from = _ref2[0], to = _ref2[1], gridTo = _ref2[2];
      return {
        value: tick,
        from,
        to,
        gridTo
      };
    });
    return import_react6.default.createElement("g", {
      key: "Axis-Group " + (isOuter ? "outer" : "inner"),
      className: "Axis-Group " + (isOuter ? "outer" : "inner"),
      style: {
        transform: isOuter ? void 0 : translate(gridDimensions.left, gridDimensions.top)
      }
    }, import_react6.default.createElement("g", {
      className: "Axis",
      style: _extends({}, isOuter ? {
        opacity: showDebugAxes ? 0.5 : 0,
        pointerEvents: "none"
      } : {
        opacity: 1,
        pointerEvents: "all"
      })
    }, import_react6.default.createElement("g", {
      className: "domainAndTicks"
    }, import_react6.default.createElement("line", {
      className: "domain",
      x1: lineFrom.x,
      y1: lineFrom.y,
      x2: lineTo2.x,
      y2: lineTo2.y,
      stroke: dark ? "rgba(255,255,255, .2)" : "rgba(0,0,0, .2)"
    }), ticks.map(function(tick, i) {
      var _tick$to = tick.to, tickLabelX = _tick$to.x, tickLabelY = _tick$to.y;
      if (axis.position === "top") {
        tickLabelY -= 5;
      } else if (axis.position === "bottom") {
        tickLabelY += 5;
      } else if (axis.position === "left") {
        tickLabelX -= 5;
      } else if (axis.position === "right") {
        tickLabelX += 5;
      }
      return import_react6.default.createElement("g", {
        key: "vx-tick-" + tick + "-" + i,
        className: "tick"
      }, !isOuter ? import_react6.default.createElement("line", {
        x1: tick.from.x,
        y1: tick.from.y,
        x2: tick.to.x,
        y2: tick.to.y,
        stroke: dark ? "rgba(255,255,255, .2)" : "rgba(0,0,0, .2)"
      }) : null, import_react6.default.createElement("text", {
        className: "tickLabel",
        style: {
          fontSize: 10,
          fill: dark ? "rgba(255,255,255, .7)" : "rgba(0,0,0, .7)",
          dominantBaseline: isRotated ? "central" : axis.position === "bottom" ? "hanging" : axis.position === "top" ? "alphabetic" : "central",
          textAnchor: isRotated ? "end" : axis.position === "right" ? "start" : axis.position === "left" ? "end" : "middle"
        },
        transform: "translate(" + tickLabelX + ", " + tickLabelY + ") rotate(" + (isRotated ? axis.position === "top" ? 60 : -60 : 0) + ")"
      }, axis.formatters.scale(tick.value)));
    })), import_react6.default.createElement("g", {
      className: "grid"
    }, ticks.map(function(tick, i) {
      var _axis$showGrid;
      return import_react6.default.createElement("g", {
        key: "vx-tick-" + tick + "-" + i,
        className: "tick"
      }, ((_axis$showGrid = axis.showGrid) != null ? _axis$showGrid : true) && !isOuter ? import_react6.default.createElement("line", {
        x1: tick.from.x,
        y1: tick.from.y,
        x2: tick.gridTo.x,
        y2: tick.gridTo.y,
        stroke: dark ? "rgba(255,255,255, .05)" : "rgba(0,0,0, .05)"
      }) : null);
    }))));
  };
  return axis.show ? import_react6.default.createElement("g", {
    ref: elRef
  }, renderAxis(false), renderAxis(true)) : null;
}
function getTickPx(scale, value) {
  var _scale;
  var px = (_scale = scale(value)) != null ? _scale : NaN;
  if (scale.bandwidth) {
    return px + scale.bandwidth() / 2;
  }
  return px;
}

// node_modules/react-charts/es/components/Cursors.js
var import_react11 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/react-charts/es/hooks/usePrevious.js
var import_react7 = __toESM(require_react());
function usePrevious(val) {
  var ref = import_react7.default.useRef();
  useIsomorphicLayoutEffect_default(function() {
    ref.current = val;
  }, [val]);
  return ref.current;
}

// node_modules/react-charts/es/hooks/useLatestWhen.js
var import_react8 = __toESM(require_react());
function useLatestWhen(obj, when) {
  if (when === void 0) {
    when = true;
  }
  var ref = import_react8.default.useRef(when ? obj : null);
  if (when) {
    ref.current = obj;
  }
  return ref.current;
}

// node_modules/react-charts/es/hooks/usePortalElement.js
var React10 = __toESM(require_react());
function usePortalElement() {
  var _React$useState = React10.useState(), portalEl = _React$useState[0], setPortalEl = _React$useState[1];
  useIsomorphicLayoutEffect_default(function() {
    if (!portalEl) {
      var element = document.getElementById("react-charts-portal");
      if (!element) {
        element = document.createElement("div");
        element.setAttribute("id", "react-charts-portal");
        Object.assign(element.style, {
          pointerEvents: "none",
          position: "fixed",
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
          "z-index": 99999999999
        });
        document.body.append(element);
      }
      setPortalEl(element);
    }
  });
  return portalEl;
}

// node_modules/react-charts/es/hooks/useRect.js
var import_react9 = __toESM(require_react());
function useRect(element, enabled) {
  var rerender = import_react9.default.useReducer(function() {
    return {};
  }, [])[1];
  var rectRef = import_react9.default.useRef({
    width: 0,
    height: 0,
    x: 0,
    y: 0,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  });
  var measure = import_react9.default.useCallback(function() {
    if (element) {
      rectRef.current = element.getBoundingClientRect();
    }
  }, [element]);
  if (!rectRef.current) {
    measure();
  }
  import_react9.default.useEffect(function() {
    if (!element || !enabled) {
      return;
    }
    var cb = function cb2() {
      measure();
      rerender();
    };
    document.addEventListener("scroll", cb, true);
    return function() {
      document.removeEventListener("scroll", cb, true);
    };
  }, [element, enabled, measure, rerender]);
  import_react9.default.useEffect(function() {
    if (!element || !enabled) {
      return;
    }
    measure();
    rerender();
    var observer = new ResizeObserver(function() {
      measure();
      rerender();
    });
    observer.observe(element);
    return function() {
      observer.unobserve(element);
    };
  }, [element, enabled, measure, rerender]);
  return rectRef.current;
}

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t4) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e3) {
    return t4.__proto__ = e3, t4;
  }, _setPrototypeOf(t, e);
}

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p, r.prototype), p;
}

// node_modules/react-charts/es/hooks/useSpring.js
var import_react10 = __toESM(require_react());

// node_modules/react-charts/es/utils/spring.js
var epsilon3 = 1e-3;
function almostEqual(a2, b) {
  if (Number.isNaN(a2) && Number.isNaN(b)) {
    return true;
  }
  return a2 > b - epsilon3 && a2 < b + epsilon3;
}
function almostZero(a2) {
  return almostEqual(a2, 0);
}
var Spring = function() {
  function Spring2(init, mass, springConstant, damping) {
    this._m = mass;
    this._k = springConstant;
    this._c = damping;
    this._solution = null;
    this.endPosition = init;
    this._startTime = 0;
  }
  var _proto = Spring2.prototype;
  _proto.x = function x2(dt) {
    if (dt === void 0) {
      dt = ((/* @__PURE__ */ new Date()).getTime() - this._startTime) / 1e3;
    }
    return this._solution ? this.endPosition + this._solution.x(dt) : this.endPosition;
  };
  _proto.dx = function dx(dt) {
    if (dt === void 0) {
      dt = ((/* @__PURE__ */ new Date()).getTime() - this._startTime) / 1e3;
    }
    return this._solution ? this._solution.dx(dt) : 0;
  };
  _proto.setEnd = function setEnd(x2) {
    var t = (/* @__PURE__ */ new Date()).getTime();
    var velocity = 0;
    var position = this.endPosition;
    if (this._solution) {
      if (almostZero(velocity)) velocity = this._solution.dx((t - this._startTime) / 1e3);
      position = this._solution.x((t - this._startTime) / 1e3);
      if (almostZero(velocity)) velocity = 0;
      if (almostZero(position)) position = 0;
      position += this.endPosition;
    }
    if (this._solution && almostZero(position - x2) && almostZero(velocity)) {
      return;
    }
    this.endPosition = x2;
    this._solution = this._solve(position - this.endPosition, velocity);
    this._startTime = t;
  };
  _proto.snap = function snap(x2) {
    this._startTime = (/* @__PURE__ */ new Date()).getTime();
    this.endPosition = x2;
    this._solution = {
      x: function x3() {
        return 0;
      },
      dx: function dx() {
        return 0;
      }
    };
  };
  _proto.done = function done() {
    return almostEqual(this.x(), this.endPosition) && almostZero(this.dx());
  };
  _proto._solve = function _solve(initial, velocity) {
    var c = this._c;
    var m = this._m;
    var k2 = this._k;
    var cmk = c * c - 4 * m * k2;
    if (cmk === 0) {
      var r = -c / (2 * m);
      var c1 = initial;
      var c2 = velocity / (r * initial);
      return {
        x: function x2(t) {
          return (c1 + c2 * t) * Math.pow(Math.E, r * t);
        },
        dx: function dx(t) {
          var pow3 = Math.pow(Math.E, r * t);
          return r * (c1 + c2 * t) * pow3 + c2 * pow3;
        }
      };
    } else if (cmk > 0) {
      var r1 = (-c - Math.sqrt(cmk)) / (2 * m);
      var r2 = (-c + Math.sqrt(cmk)) / (2 * m);
      var _c = (velocity - r1 * initial) / (r2 - r1);
      var _c2 = initial - _c;
      return {
        x: function x2(t) {
          return _c2 * Math.pow(Math.E, r1 * t) + _c * Math.pow(Math.E, r2 * t);
        },
        dx: function dx(t) {
          return _c2 * r1 * Math.pow(Math.E, r1 * t) + _c * r2 * Math.pow(Math.E, r2 * t);
        }
      };
    } else {
      var w = Math.sqrt(4 * m * k2 - c * c) / (2 * m);
      var _r = -(c / 2 * m);
      var _c3 = initial;
      var _c4 = (velocity - _r * initial) / w;
      return {
        x: function x2(t) {
          return Math.pow(Math.E, _r * t) * (_c3 * Math.cos(w * t) + _c4 * Math.sin(w * t));
        },
        dx: function dx(t) {
          var power = Math.pow(Math.E, _r * t);
          var cos2 = Math.cos(w * t);
          var sin2 = Math.sin(w * t);
          return power * (_c4 * w * cos2 - _c3 * w * sin2) + _r * power * (_c4 * sin2 + _c3 * cos2);
        }
      };
    }
  };
  return Spring2;
}();

// node_modules/react-charts/es/hooks/useSpring.js
function useSpring(value, config, cb, immediate, _debug) {
  var springRef = import_react10.default.useRef(_construct(Spring, [value].concat(config)));
  var getValue = useGetLatest(value);
  var _useRaf = useRaf(function() {
    cb(springRef.current.x());
    return springRef.current.done();
  }), startRaf = _useRaf[0], stopRaf = _useRaf[1];
  var prevRef = import_react10.default.useRef();
  var changed = prevRef.current !== value;
  import_react10.default.useEffect(function() {
    if (changed) {
      if (immediate) {
        springRef.current.snap(getValue());
        startRaf();
        return;
      }
      springRef.current.setEnd(value);
      startRaf();
    }
    prevRef.current = value;
  });
  import_react10.default.useEffect(function() {
    return function() {
      stopRaf();
    };
  }, [stopRaf]);
  return springRef.current;
}
function useRaf(callback) {
  var raf = import_react10.default.useRef(null);
  var rafCallback = import_react10.default.useRef(callback);
  rafCallback.current = callback;
  var tick = import_react10.default.useCallback(function() {
    if (rafCallback.current()) return;
    raf.current = requestAnimationFrame(tick);
  }, []);
  return [import_react10.default.useMemo(function() {
    return tick;
  }, [tick]), import_react10.default.useMemo(function() {
    return function() {
      return raf.current && cancelAnimationFrame(raf.current);
    };
  }, [])];
}

// node_modules/react-charts/es/components/Cursors.js
var getLineBackgroundColor = function getLineBackgroundColor2(dark, bandWidth) {
  return dark ? "rgba(255,255,255," + (bandWidth > 4 ? 0.15 : 0.3) + ")" : "rgba(0, 26, 39, " + (bandWidth > 4 ? 0.15 : 0.3) + ")";
};
var getBackgroundColor = function getBackgroundColor2(dark) {
  return dark ? "rgba(255,255,255,.9)" : "rgba(0, 26, 39, 0.9)";
};
function defaultCursor(options) {
  var _options$show, _options$showLine, _options$showLabel;
  return _extends({}, options, {
    show: (_options$show = options.show) != null ? _options$show : true,
    showLine: (_options$showLine = options.showLine) != null ? _options$showLine : true,
    showLabel: (_options$showLabel = options.showLabel) != null ? _options$showLabel : true
  });
}
function Cursors() {
  var _getOptions$primaryCu, _getOptions$secondary;
  var _useChartContext = useChartContext(), getOptions = _useChartContext.getOptions;
  var primaryOptions = (_getOptions$primaryCu = getOptions().primaryCursor) != null ? _getOptions$primaryCu : true;
  var secondaryOptions = (_getOptions$secondary = getOptions().secondaryCursor) != null ? _getOptions$secondary : true;
  var resolvedPrimaryOptions = import_react11.default.useMemo(function() {
    return defaultCursor(!primaryOptions ? {
      show: false
    } : typeof primaryOptions === "boolean" ? {} : primaryOptions);
  }, [primaryOptions]);
  var resolvedSecondaryOptions = import_react11.default.useMemo(function() {
    return defaultCursor(!secondaryOptions ? {
      show: false
    } : typeof secondaryOptions === "boolean" ? {} : secondaryOptions);
  }, [secondaryOptions]);
  return import_react11.default.createElement(import_react11.default.Fragment, null, resolvedPrimaryOptions.show && import_react11.default.createElement(Cursor, {
    primary: true,
    options: resolvedPrimaryOptions
  }), resolvedSecondaryOptions.show && import_react11.default.createElement(Cursor, {
    options: resolvedSecondaryOptions
  }));
}
function Cursor(props) {
  var _secondaryAxes$find, _props$options$value, _ref, _ref2, _ref3, _ref4, _getOptions$dark;
  var _useChartContext2 = useChartContext(), getOptions = _useChartContext2.getOptions, svgRef = _useChartContext2.svgRef, gridDimensions = _useChartContext2.gridDimensions, focusedDatumState = _useChartContext2.focusedDatumState, primaryAxis = _useChartContext2.primaryAxis, secondaryAxes = _useChartContext2.secondaryAxes;
  var getTooltipOptions = useGetLatest(props.options);
  var focusedDatum = focusedDatumState[0];
  var latestFocusedDatum = useLatestWhen(focusedDatum, !!focusedDatum);
  var secondaryAxis = (_secondaryAxes$find = secondaryAxes.find(function(d) {
    return d.id === (latestFocusedDatum == null ? void 0 : latestFocusedDatum.secondaryAxisId);
  })) != null ? _secondaryAxes$find : secondaryAxes[0];
  var axis = props.primary ? primaryAxis : secondaryAxis;
  var siblingAxis = props.primary ? secondaryAxis : primaryAxis;
  var resolveValue = function resolveValue2(d) {
    var _d$stackData;
    return d ? axis.stacked ? (_d$stackData = d.stackData) == null ? void 0 : _d$stackData[1] : props.primary ? d.primaryValue : d.secondaryValue : void 0;
  };
  var datumValue = resolveValue(focusedDatum);
  import_react11.default.useEffect(function() {
    var _getTooltipOptions;
    (_getTooltipOptions = getTooltipOptions()) == null ? void 0 : _getTooltipOptions.onChange == null ? void 0 : _getTooltipOptions.onChange(datumValue);
  }, [getTooltipOptions, datumValue]);
  var value = (_props$options$value = props.options.value) != null ? _props$options$value : datumValue;
  var latestPropsValue = useLatestWhen(props.options.value, props.options.value != null);
  var latestDatumValue = useLatestWhen(resolveValue(latestFocusedDatum), resolveValue(latestFocusedDatum) != null);
  var latestValue = latestPropsValue != null ? latestPropsValue : latestDatumValue;
  var siblingRange = siblingAxis.scale.range();
  var x2;
  var y2;
  var x1;
  var x22;
  var y1;
  var y22;
  var alignPctX;
  var alignPctY;
  var bandWidth = axis.axisFamily === "band" ? axis.scale.bandwidth() : 1;
  var show = typeof value !== "undefined" && !Number.isNaN(value);
  var px = axis.scale(value);
  if (axis.isVertical) {
    var _y, _y2;
    y2 = px;
    y1 = ((_y = y2) != null ? _y : 0) - 1;
    y22 = ((_y2 = y2) != null ? _y2 : 0) + bandWidth;
    if (axis.position === "left") {
      x1 = siblingRange[0];
      x22 = siblingRange[1];
    } else {
      x1 = siblingRange[1];
      x22 = siblingRange[0];
    }
  } else {
    var _x, _x2;
    x2 = px;
    x1 = ((_x = x2) != null ? _x : 0) - 1;
    x22 = ((_x2 = x2) != null ? _x2 : 0) + bandWidth;
    if (axis.position === "top") {
      y1 = siblingRange[0];
      y22 = siblingRange[1];
    } else {
      y1 = siblingRange[1];
      y22 = siblingRange[0];
    }
  }
  var lineStartX = Math.min(x1, x22);
  var lineStartY = Math.min(y1, y22);
  var lineEndX = Math.max(x1, x22);
  var lineEndY = Math.max(y1, y22);
  var lineHeight = Math.max(lineEndY - lineStartY, 0);
  var lineWidth = Math.max(lineEndX - lineStartX, 0);
  var bubbleX;
  var bubbleY;
  if (axis.isVertical) {
    if (axis.position === "left") {
      bubbleX = lineStartX;
    } else {
      bubbleX = lineEndX;
    }
    bubbleY = lineStartY + lineHeight / 2;
  } else {
    if (axis.position === "top") {
      bubbleY = lineStartY;
    } else {
      bubbleY = lineEndY;
    }
    bubbleX = lineStartX + lineWidth / 2;
  }
  if (axis.isVertical) {
    alignPctY = -50;
    if (axis.position === "left") {
      alignPctX = -100;
    } else {
      alignPctX = 0;
    }
  } else {
    alignPctX = -50;
    if (axis.position === "top") {
      alignPctY = -100;
    } else {
      alignPctY = 0;
    }
  }
  var formattedValue = axis.formatters.cursor(latestValue);
  var svgRect = useRect(svgRef.current, show);
  var lineRef = import_react11.default.useRef(null);
  var bubbleRef = import_react11.default.useRef(null);
  var latestLineStartX = useLatestWhen(lineStartX, px != null);
  var latestLineStartY = useLatestWhen(lineStartY, px != null);
  var latestBubbleX = useLatestWhen(bubbleX, px != null);
  var latestBubbleY = useLatestWhen(bubbleY, px != null);
  var previousTruePx = usePrevious(px);
  var immediate = previousTruePx == null && px !== null;
  lineStartX = (_ref = px != null ? lineStartX : latestLineStartX) != null ? _ref : NaN;
  lineStartY = (_ref2 = px != null ? lineStartY : latestLineStartY) != null ? _ref2 : NaN;
  bubbleX = (_ref3 = px != null ? bubbleX : latestBubbleX) != null ? _ref3 : NaN;
  bubbleY = (_ref4 = px != null ? bubbleY : latestBubbleY) != null ? _ref4 : NaN;
  var lineXSpring = useSpring(lineStartX, [1, 210, 20], function() {
    if (lineRef.current) {
      lineRef.current.style.transform = "translate(" + lineXSpring.x() + "px, " + lineYSpring.x() + "px)";
    }
  }, immediate);
  var lineYSpring = useSpring(lineStartY, [1, 210, 20], function() {
    if (lineRef.current) {
      lineRef.current.style.transform = "translate(" + lineXSpring.x() + "px, " + lineYSpring.x() + "px)";
    }
  }, immediate);
  var bubbleXSpring = useSpring(bubbleX, [1, 210, 20], function() {
    if (bubbleRef.current) {
      bubbleRef.current.style.transform = "translate(" + bubbleXSpring.x() + "px, " + bubbleYSpring.x() + "px)";
    }
  }, immediate);
  var bubbleYSpring = useSpring(bubbleY, [1, 210, 20], function() {
    if (bubbleRef.current) {
      bubbleRef.current.style.transform = "translate(" + bubbleXSpring.x() + "px, " + bubbleYSpring.x() + "px)";
    }
  }, immediate);
  var portalEl = usePortalElement();
  return portalEl ? import_react_dom.default.createPortal(import_react11.default.createElement("div", {
    style: {
      fontFamily: "sans-serif",
      pointerEvents: "none",
      position: "absolute",
      top: 0,
      left: 0,
      transform: translate(svgRect.left + gridDimensions.left, svgRect.top + gridDimensions.top),
      opacity: show ? 1 : 0,
      transition: "opacity .3s ease"
    },
    className: "Cursor"
  }, props.options.showLine ? import_react11.default.createElement("div", {
    ref: lineRef,
    style: {
      width: lineWidth + "px",
      height: lineHeight + "px",
      position: "absolute",
      top: 0,
      left: 0,
      background: getLineBackgroundColor((_getOptions$dark = getOptions().dark) != null ? _getOptions$dark : false, bandWidth)
    }
  }) : null, props.options.showLabel ? import_react11.default.createElement("div", {
    ref: bubbleRef,
    style: {
      position: "absolute",
      top: 0,
      left: 0
    }
  }, import_react11.default.createElement("div", {
    style: {
      padding: "5px",
      fontSize: "10px",
      background: getBackgroundColor(getOptions().dark),
      color: getBackgroundColor(!getOptions().dark),
      borderRadius: "3px",
      position: "relative",
      transform: "translate3d(" + alignPctX + "%, " + alignPctY + "%, 0)",
      whiteSpace: "nowrap"
    }
  }, formattedValue)) : null), portalEl) : null;
}

// node_modules/react-charts/es/components/Tooltip.js
var import_react14 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/react-charts/es/hooks/useAnchor.js
var import_react12 = __toESM(require_react());
var sideSchemas = {
  left: {
    side: "left",
    startKey: "left",
    lengthKey: "width",
    crossStartKey: "top",
    crossLengthKey: "height",
    fromEnd: false
  },
  right: {
    side: "right",
    startKey: "left",
    lengthKey: "width",
    crossStartKey: "top",
    crossLengthKey: "height",
    fromEnd: true
  },
  top: {
    side: "top",
    startKey: "top",
    lengthKey: "height",
    crossStartKey: "left",
    crossLengthKey: "width",
    fromEnd: false
  },
  bottom: {
    side: "bottom",
    startKey: "top",
    lengthKey: "height",
    crossStartKey: "left",
    crossLengthKey: "width",
    fromEnd: true
  }
};
function useAnchor(options) {
  var portalDims = useRect(options.portalEl, options.show);
  var anchorDims = useRect(options.anchorEl, options.show);
  var tooltipDims = useRect(options.tooltipEl, options.show);
  var sides = import_react12.default.useMemo(function() {
    var preSides = Array.isArray(options.side) ? options.side : [options.side];
    return preSides.map(function(alignStr) {
      var _ref = alignStr.split(" "), side = _ref[0], _ref$ = _ref[1], align = _ref$ === void 0 ? "center" : _ref$;
      var incompatibleSide = !["top", "right", "bottom", "left"].find(function(d) {
        return side === d;
      });
      if (incompatibleSide) {
        throw new Error('react-sticker: "' + side + `" is not a valid side! Must be one of ['top', 'right', 'bottom', 'left'].`);
      }
      var incompatibleAlign = !["center", "start", "end", "top", "right", "bottom", "left"].find(function(d) {
        return align === d;
      });
      if (incompatibleAlign) {
        throw new Error('react-sticker: "' + align + `" is not a valid side-alignment! Must be one of ['center', 'start', 'end', 'top', 'right', 'bottom', 'left'].`);
      }
      return [side, align];
    });
  }, [JSON.stringify(options.side)]);
  var ready = portalDims && tooltipDims && anchorDims;
  var fit = import_react12.default.useMemo(function() {
    return ready && options.show ? fitOnBestSide({
      portalDims,
      tooltipDims,
      anchorDims,
      sides,
      useLargest: options.useLargest
    }) : null;
  }, [anchorDims, options.show, options.useLargest, portalDims, ready, sides, tooltipDims]);
  return {
    fit,
    style: _extends({
      position: "absolute",
      visibility: ready ? "visible" : "hidden"
    }, fit == null ? void 0 : fit.style)
  };
}
function fitOnBestSide(_ref2) {
  var portalDims = _ref2.portalDims, tooltipDims = _ref2.tooltipDims, anchorDims = _ref2.anchorDims, sides = _ref2.sides, useLargest = _ref2.useLargest;
  var fits = sides.map(function(_ref3) {
    var side = _ref3[0], align = _ref3[1];
    return measureFit(_extends({}, sideSchemas[side], {
      align,
      portalDims,
      tooltipDims,
      anchorDims
    }));
  });
  if (useLargest) {
    fits.sort(function(a2, b) {
      return b.fitRatio - a2.fitRatio;
    });
    return fits[0];
  }
  return fits.find(function(fit) {
    return fit.fitRatio >= 1;
  }) || fits[0];
}
function measureFit(_ref4) {
  var _style;
  var side = _ref4.side, align = _ref4.align, startKey = _ref4.startKey, lengthKey = _ref4.lengthKey, crossStartKey = _ref4.crossStartKey, crossLengthKey = _ref4.crossLengthKey, fromEnd = _ref4.fromEnd, portalDims = _ref4.portalDims, tooltipDims = _ref4.tooltipDims, anchorDims = _ref4.anchorDims;
  var parentStart = portalDims[startKey];
  var parentLength = portalDims[lengthKey];
  var crossParentStart = portalDims[crossStartKey];
  var crossParentLength = portalDims[crossLengthKey];
  var anchorStart = anchorDims[startKey] - portalDims[startKey];
  var anchorLength = anchorDims[lengthKey];
  var crossAnchorStart = anchorDims[crossStartKey];
  var crossAnchorLength = anchorDims[crossLengthKey];
  var crossAnchorWidth = anchorDims[crossLengthKey];
  var targetLength = tooltipDims[lengthKey];
  var crossTargetLength = tooltipDims[crossLengthKey];
  var targetStart;
  var fitRatio;
  if (!fromEnd) {
    targetStart = anchorStart - targetLength;
    fitRatio = Math.min(anchorStart / targetLength);
  } else {
    targetStart = anchorStart + anchorLength;
    fitRatio = (parentLength - (anchorStart + anchorLength)) / targetLength;
  }
  targetStart = Math.max(parentStart, Math.min(targetStart, parentLength));
  var crossTargetStart;
  if (startKey === "left") {
    if (align === "top") {
      align = "start";
    } else if (align === "bottom") {
      align = "end";
    }
  } else {
    if (align === "left") {
      align = "start";
    } else if (align === "right") {
      align = "end";
    }
  }
  if (!["start", "center", "end"].includes(align)) {
    align = "center";
  }
  if (align === "start") {
    crossTargetStart = crossAnchorStart;
  } else if (align === "end") {
    crossTargetStart = crossAnchorStart + crossAnchorWidth - crossTargetLength;
  } else {
    crossTargetStart = crossAnchorStart + crossAnchorLength / 2 - crossTargetLength / 2;
  }
  crossTargetStart = Math.max(crossParentStart, Math.min(crossTargetStart, crossParentLength - crossTargetLength));
  return {
    side,
    align,
    startKey,
    lengthKey,
    crossStartKey,
    crossLengthKey,
    fromEnd,
    portalDims,
    tooltipDims,
    anchorDims,
    fitRatio,
    style: (_style = {}, _style[startKey] = targetStart, _style[crossStartKey] = crossTargetStart, _style)
  };
}

// node_modules/react-charts/es/components/TooltipRenderer.js
var import_react13 = __toESM(require_react());
var showCount = 10;
var triangleSize = 7;
var getBackgroundColor3 = function getBackgroundColor4(dark) {
  return dark ? "rgba(255,255,255,.9)" : "rgba(0, 26, 39, 0.9)";
};
function tooltipRenderer(props) {
  return import_react13.default.createElement(TooltipRenderer, props);
}
function TooltipRenderer(props) {
  var _props$focusedDatum$t, _props$focusedDatum, _focusedDatum$tooltip;
  var latestFit = useLatestWhen(props.anchor.fit, !!props.anchor.fit);
  if (!props.focusedDatum) {
    return null;
  }
  var primaryAxis = props.primaryAxis, secondaryAxis = props.secondaryAxis, getDatumStyle = props.getDatumStyle, focusedDatum = props.focusedDatum, secondaryAxes = props.secondaryAxes;
  var _props$getOptions = props.getOptions(), tooltip = _props$getOptions.tooltip, dark = _props$getOptions.dark;
  var groupDatums = ((_props$focusedDatum$t = (_props$focusedDatum = props.focusedDatum) == null ? void 0 : _props$focusedDatum.tooltipGroup) != null ? _props$focusedDatum$t : []).filter(function(datum) {
    var _tooltip$showDatumInT;
    return (_tooltip$showDatumInT = tooltip.showDatumInTooltip == null ? void 0 : tooltip.showDatumInTooltip(datum)) != null ? _tooltip$showDatumInT : true;
  });
  var resolvedShowCount = showCount % 2 === 0 ? showCount : showCount + 1;
  var length = groupDatums.length;
  var activeIndex = groupDatums.findIndex(function(d) {
    return d === focusedDatum;
  });
  var start = activeIndex > -1 ? activeIndex - resolvedShowCount / 2 : 0;
  start = Math.max(start, 0);
  var end = activeIndex > -1 ? start + resolvedShowCount : length;
  end = Math.min(end, length);
  start = Math.max(end - resolvedShowCount, 0);
  var visibleSortedGroupDatums = groupDatums.slice(start, end);
  var hasPrevious = start > 0;
  var hasNext = end < length;
  var finalAlign = (latestFit == null ? void 0 : latestFit.side) + "-" + (latestFit == null ? void 0 : latestFit.align);
  var arrowPosition;
  var triangleStyles;
  if (!arrowPosition) {
    if (finalAlign === "left-center") {
      arrowPosition = "right";
    } else if (finalAlign === "right-center") {
      arrowPosition = "left";
    } else if (finalAlign === "top-center") {
      arrowPosition = "bottom";
    } else if (finalAlign === "bottom-center") {
      arrowPosition = "top";
    } else if (finalAlign === "right-start") {
      arrowPosition = "bottomLeft";
    } else if (finalAlign === "right-end") {
      arrowPosition = "topLeft";
    } else if (finalAlign === "left-start") {
      arrowPosition = "bottomRight";
    } else if (finalAlign === "left-end") {
      arrowPosition = "topRight";
    }
  }
  var backgroundColor = getBackgroundColor3(dark);
  if (arrowPosition === "bottom") {
    triangleStyles = {
      top: "100%",
      left: "50%",
      transform: "translate3d(-50%, 0%, 0)",
      borderLeft: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize * 0.8 + "px solid transparent",
      borderTop: triangleSize + "px solid " + backgroundColor
    };
  } else if (arrowPosition === "top") {
    triangleStyles = {
      top: "0%",
      left: "50%",
      transform: "translate3d(-50%, -100%, 0)",
      borderLeft: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize + "px solid " + backgroundColor
    };
  } else if (arrowPosition === "right") {
    triangleStyles = {
      top: "50%",
      left: "100%",
      transform: "translate3d(0%, -50%, 0)",
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderLeft: triangleSize + "px solid " + backgroundColor
    };
  } else if (arrowPosition === "left") {
    triangleStyles = {
      top: "50%",
      left: "0%",
      transform: "translate3d(-100%, -50%, 0)",
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize + "px solid " + backgroundColor
    };
  } else if (arrowPosition === "topRight") {
    triangleStyles = {
      top: "0%",
      left: "100%",
      transform: "translate3d(-50%, -50%, 0) rotate(-45deg)",
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderLeft: triangleSize * 2 + "px solid " + backgroundColor
    };
  } else if (arrowPosition === "bottomRight") {
    triangleStyles = {
      top: "100%",
      left: "100%",
      transform: "translate3d(-50%, -50%, 0) rotate(45deg)",
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderLeft: triangleSize * 2 + "px solid " + backgroundColor
    };
  } else if (arrowPosition === "topLeft") {
    triangleStyles = {
      top: "0%",
      left: "0%",
      transform: "translate3d(-50%, -50%, 0) rotate(45deg)",
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize * 2 + "px solid " + backgroundColor
    };
  } else if (arrowPosition === "bottomLeft") {
    triangleStyles = {
      top: "100%",
      left: "0%",
      transform: "translate3d(-50%, -50%, 0) rotate(-45deg)",
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize * 2 + "px solid " + backgroundColor
    };
  } else {
    triangleStyles = {
      opacity: 0
    };
  }
  return import_react13.default.createElement("div", {
    style: {
      position: "relative",
      fontSize: "10px",
      padding: "5px",
      background: getBackgroundColor3(dark),
      color: dark ? "black" : "white",
      borderRadius: "3px"
    }
  }, import_react13.default.createElement("div", {
    style: _extends({
      position: "absolute",
      width: 0,
      height: 0
    }, triangleStyles)
  }), import_react13.default.createElement("div", null, import_react13.default.createElement("div", {
    style: {
      marginBottom: "3px",
      textAlign: "center"
    }
  }, tooltip.groupingMode === "series" ? import_react13.default.createElement("strong", null, focusedDatum.seriesLabel) : tooltip.groupingMode === "secondary" ? import_react13.default.createElement("strong", null, secondaryAxis.formatters.tooltip(focusedDatum.secondaryValue)) : import_react13.default.createElement("strong", null, primaryAxis.formatters.tooltip(focusedDatum.primaryValue))), import_react13.default.createElement("table", {
    style: {
      whiteSpace: "nowrap"
    }
  }, import_react13.default.createElement("tbody", null, hasPrevious ? import_react13.default.createElement("tr", {
    style: {
      opacity: 0.8
    }
  }, import_react13.default.createElement("td", null), import_react13.default.createElement("td", null, "..."), import_react13.default.createElement("td", null)) : null, visibleSortedGroupDatums.map(function(sortedDatum, i) {
    var active = sortedDatum === focusedDatum;
    var datumSecondaryAxis = secondaryAxes.find(function(d) {
      return d.id === sortedDatum.secondaryAxisId;
    });
    return import_react13.default.createElement("tr", {
      key: i,
      style: {
        opacity: active ? 1 : 0.8,
        fontWeight: active ? "bold" : void 0
      }
    }, import_react13.default.createElement("td", {
      style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      }
    }, import_react13.default.createElement("svg", {
      width: "14",
      height: "14"
    }, import_react13.default.createElement("circle", {
      cx: "7",
      cy: "7",
      r: "5",
      style: _extends({}, getDatumStyle(sortedDatum), {
        stroke: dark ? "black" : "white",
        strokeWidth: active ? 2 : 1
      })
    }))), tooltip.groupingMode === "series" ? import_react13.default.createElement(import_react13.default.Fragment, null, import_react13.default.createElement("td", null, primaryAxis.formatters.tooltip(sortedDatum.primaryValue), ": "), import_react13.default.createElement("td", {
      style: {
        textAlign: "right"
      }
    }, datumSecondaryAxis.formatters.tooltip(sortedDatum.secondaryValue))) : tooltip.groupingMode === "secondary" ? import_react13.default.createElement(import_react13.default.Fragment, null, import_react13.default.createElement("td", null, sortedDatum.seriesLabel, ": "), import_react13.default.createElement("td", {
      style: {
        textAlign: "right"
      }
    }, primaryAxis.formatters.tooltip(sortedDatum.primaryValue))) : import_react13.default.createElement(import_react13.default.Fragment, null, import_react13.default.createElement("td", null, sortedDatum.seriesLabel, ": "), import_react13.default.createElement("td", {
      style: {
        textAlign: "right"
      }
    }, datumSecondaryAxis.formatters.tooltip(sortedDatum.secondaryValue))));
  }), hasNext ? import_react13.default.createElement("tr", {
    style: {
      opacity: 0.8
    }
  }, import_react13.default.createElement("td", null), import_react13.default.createElement("td", null, "..."), import_react13.default.createElement("td", null)) : null, ((_focusedDatum$tooltip = focusedDatum.tooltipGroup) != null ? _focusedDatum$tooltip : []).length > 1 ? props.secondaryAxes.filter(function(d) {
    return d.stacked;
  }).map(function(secondaryAxis2, i) {
    var _secondaryAxis$id, _focusedDatum$tooltip2;
    return import_react13.default.createElement("tr", {
      key: secondaryAxis2.id + "_" + i
    }, import_react13.default.createElement("td", {
      style: {
        paddingTop: "5px"
      }
    }, import_react13.default.createElement("div", {
      style: {
        width: "12px",
        height: "12px",
        backgroundColor: dark ? "rgba(0, 26, 39, 0.3)" : "rgba(255,255,255,.2)",
        borderRadius: "50px"
      }
    })), import_react13.default.createElement("td", {
      style: {
        paddingTop: "5px"
      }
    }, props.secondaryAxes.length > 1 ? (_secondaryAxis$id = secondaryAxis2.id) != null ? _secondaryAxis$id : "Axis " + (i + 1) + " " : "", "Total: "), import_react13.default.createElement("td", {
      style: {
        paddingTop: "5px"
      }
    }, secondaryAxis2.formatters.scale(sum((_focusedDatum$tooltip2 = focusedDatum.tooltipGroup) != null ? _focusedDatum$tooltip2 : [], function(d) {
      return d.secondaryValue;
    }))));
  }) : null))));
}

// node_modules/react-charts/es/components/Tooltip.js
var _excluded = ["visibility"];
function defaultTooltip(options) {
  var _options$align, _options$alignPriorit, _options$padding, _options$arrowPadding, _options$render, _options$showDatumInT;
  if (options === void 0) {
    options = {};
  }
  if (options === true) {
    options = {
      show: true
    };
  } else if (options === false) {
    options = {
      show: false
    };
  }
  return _extends({
    show: true
  }, options, {
    align: (_options$align = options.align) != null ? _options$align : "auto",
    alignPriority: (_options$alignPriorit = options.alignPriority) != null ? _options$alignPriorit : ["right", "topRight", "bottomRight", "left", "topLeft", "bottomLeft", "top", "bottom"],
    padding: (_options$padding = options.padding) != null ? _options$padding : 5,
    arrowPadding: (_options$arrowPadding = options.arrowPadding) != null ? _options$arrowPadding : 7,
    // anchor: options.anchor ?? 'closest',
    render: (_options$render = options.render) != null ? _options$render : tooltipRenderer,
    showDatumInTooltip: (_options$showDatumInT = options.showDatumInTooltip) != null ? _options$showDatumInT : function() {
      return true;
    }
  });
}
function Tooltip() {
  var _secondaryAxes$find, _useLatestWhen;
  var _useChartContext = useChartContext(), focusedDatumState = _useChartContext.focusedDatumState, getOptions = _useChartContext.getOptions, primaryAxis = _useChartContext.primaryAxis, secondaryAxes = _useChartContext.secondaryAxes, getDatumStatusStyle = _useChartContext.getDatumStatusStyle, svgRef = _useChartContext.svgRef;
  var focusedDatum = focusedDatumState[0];
  var latestFocusedDatum = useLatestWhen(focusedDatum, !!focusedDatum);
  var secondaryAxis = (_secondaryAxes$find = secondaryAxes.find(function(d) {
    return d.id === (latestFocusedDatum == null ? void 0 : latestFocusedDatum.secondaryAxisId);
  })) != null ? _secondaryAxes$find : secondaryAxes[0];
  var portalEl = usePortalElement();
  var _React$useState = import_react14.default.useState(), tooltipEl = _React$useState[0], setTooltipEl = _React$useState[1];
  var svgRect = useRect(svgRef.current, !!(focusedDatum != null && focusedDatum.element));
  var anchorEl = import_react14.default.useMemo(function() {
    var _latestFocusedDatum$e, _latestFocusedDatum$e2, _anchorRect$left, _anchorRect$top, _anchorRect$width, _anchorRect$height;
    var anchorRect = (_latestFocusedDatum$e = latestFocusedDatum == null ? void 0 : (_latestFocusedDatum$e2 = latestFocusedDatum.element) == null ? void 0 : _latestFocusedDatum$e2.getBoundingClientRect()) != null ? _latestFocusedDatum$e : null;
    if (!anchorRect) {
      return null;
    }
    if (!svgRect) return;
    var translateX = (_anchorRect$left = anchorRect.left) != null ? _anchorRect$left : 0;
    var translateY = (_anchorRect$top = anchorRect.top) != null ? _anchorRect$top : 0;
    var width = (_anchorRect$width = anchorRect.width) != null ? _anchorRect$width : 0;
    var height = (_anchorRect$height = anchorRect.height) != null ? _anchorRect$height : 0;
    var el = document.createElement("div");
    el.getBoundingClientRect = function() {
      return {
        x: translateX,
        y: translateY,
        width,
        height,
        top: translateY,
        left: translateX,
        bottom: translateY + width,
        right: translateX + height
      };
    };
    return el;
  }, [latestFocusedDatum == null ? void 0 : latestFocusedDatum.element, svgRect]);
  var anchor = useAnchor({
    show: !!focusedDatum,
    portalEl,
    anchorEl,
    tooltipEl,
    side: ["right", "left", "top", "bottom"]
  });
  var previousAnchor = usePrevious(anchor);
  var latestStableAnchor = (_useLatestWhen = useLatestWhen(anchor, !!anchor.fit)) != null ? _useLatestWhen : anchor;
  var _latestStableAnchor$s = latestStableAnchor.style, visibility = _latestStableAnchor$s.visibility, anchorStyle = _objectWithoutPropertiesLoose(_latestStableAnchor$s, _excluded);
  var tooltipRef = import_react14.default.useRef(null);
  var immediate = Number.isNaN(previousAnchor == null ? void 0 : previousAnchor.style.left);
  var tooltipXSpring = useSpring(anchorStyle.left || 0, [1, 210, 30], function() {
    if (tooltipRef.current) {
      tooltipRef.current.style.transform = "translate(" + tooltipXSpring.x() + "px, " + tooltipYSpring.x() + "px)";
    }
  }, immediate);
  var tooltipYSpring = useSpring(anchorStyle.top || 0, [1, 210, 30], function() {
    if (tooltipRef.current) {
      tooltipRef.current.style.transform = "translate(" + tooltipXSpring.x() + "px, " + tooltipYSpring.x() + "px)";
    }
  }, immediate);
  var show = getOptions().tooltip.show;
  var latestFit = useLatestWhen(anchor.fit, !!anchor.fit);
  return show && portalEl ? import_react_dom2.default.createPortal(import_react14.default.createElement("div", {
    ref: tooltipRef,
    style: {
      position: anchorStyle.position,
      opacity: !!focusedDatum ? 1 : 0,
      transition: "opacity .3s ease"
    }
  }, import_react14.default.createElement("div", {
    ref: function ref(el) {
      return setTooltipEl(el);
    },
    style: _extends({
      fontFamily: "sans-serif"
    }, (latestFit == null ? void 0 : latestFit.startKey) === "left" ? {
      padding: "0 10px"
    } : {
      padding: "10px 0"
    })
  }, getOptions().tooltip.render({
    getOptions,
    focusedDatum: latestFocusedDatum,
    primaryAxis,
    secondaryAxes,
    secondaryAxis,
    getDatumStyle: function getDatumStyle(datum) {
      return getDatumStatusStyle(datum, focusedDatum);
    },
    anchor
  }))), portalEl) : null;
}

// node_modules/react-charts/es/components/Voronoi.js
var import_react15 = __toESM(require_react());

// node_modules/delaunator/index.js
var EPSILON = Math.pow(2, -52);
var EDGE_STACK = new Uint32Array(512);
var Delaunator = class _Delaunator {
  static from(points, getX3 = defaultGetX, getY3 = defaultGetY) {
    const n = points.length;
    const coords = new Float64Array(n * 2);
    for (let i = 0; i < n; i++) {
      const p = points[i];
      coords[2 * i] = getX3(p);
      coords[2 * i + 1] = getY3(p);
    }
    return new _Delaunator(coords);
  }
  constructor(coords) {
    const n = coords.length >> 1;
    if (n > 0 && typeof coords[0] !== "number") throw new Error("Expected coords to contain numbers.");
    this.coords = coords;
    const maxTriangles = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3);
    this._hashSize = Math.ceil(Math.sqrt(n));
    this._hullPrev = new Uint32Array(n);
    this._hullNext = new Uint32Array(n);
    this._hullTri = new Uint32Array(n);
    this._hullHash = new Int32Array(this._hashSize).fill(-1);
    this._ids = new Uint32Array(n);
    this._dists = new Float64Array(n);
    this.update();
  }
  update() {
    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
    const n = coords.length >> 1;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i = 0; i < n; i++) {
      const x2 = coords[2 * i];
      const y2 = coords[2 * i + 1];
      if (x2 < minX) minX = x2;
      if (y2 < minY) minY = y2;
      if (x2 > maxX) maxX = x2;
      if (y2 > maxY) maxY = y2;
      this._ids[i] = i;
    }
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;
    let minDist = Infinity;
    let i0, i1, i2;
    for (let i = 0; i < n; i++) {
      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist) {
        i0 = i;
        minDist = d;
      }
    }
    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    minDist = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0) continue;
      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist && d > 0) {
        i1 = i;
        minDist = d;
      }
    }
    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0 || i === i1) continue;
      const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
      if (r < minRadius) {
        i2 = i;
        minRadius = r;
      }
    }
    let i2x = coords[2 * i2];
    let i2y = coords[2 * i2 + 1];
    if (minRadius === Infinity) {
      for (let i = 0; i < n; i++) {
        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
      }
      quicksort(this._ids, this._dists, 0, n - 1);
      const hull = new Uint32Array(n);
      let j = 0;
      for (let i = 0, d0 = -Infinity; i < n; i++) {
        const id = this._ids[i];
        if (this._dists[id] > d0) {
          hull[j++] = id;
          d0 = this._dists[id];
        }
      }
      this.hull = hull.subarray(0, j);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    }
    if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
      const i = i1;
      const x2 = i1x;
      const y2 = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = i;
      i2x = x2;
      i2y = y2;
    }
    const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center.x;
    this._cy = center.y;
    for (let i = 0; i < n; i++) {
      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
    }
    quicksort(this._ids, this._dists, 0, n - 1);
    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;
    this._addTriangle(i0, i1, i2, -1, -1, -1);
    for (let k2 = 0, xp, yp; k2 < this._ids.length; k2++) {
      const i = this._ids[k2];
      const x2 = coords[2 * i];
      const y2 = coords[2 * i + 1];
      if (k2 > 0 && Math.abs(x2 - xp) <= EPSILON && Math.abs(y2 - yp) <= EPSILON) continue;
      xp = x2;
      yp = y2;
      if (i === i0 || i === i1 || i === i2) continue;
      let start = 0;
      for (let j = 0, key = this._hashKey(x2, y2); j < this._hashSize; j++) {
        start = hullHash[(key + j) % this._hashSize];
        if (start !== -1 && start !== hullNext[start]) break;
      }
      start = hullPrev[start];
      let e = start, q;
      while (q = hullNext[e], !orient(x2, y2, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {
        e = q;
        if (e === start) {
          e = -1;
          break;
        }
      }
      if (e === -1) continue;
      let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
      hullTri[i] = this._legalize(t + 2);
      hullTri[e] = t;
      hullSize++;
      let n2 = hullNext[e];
      while (q = hullNext[n2], orient(x2, y2, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1])) {
        t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
        hullTri[i] = this._legalize(t + 2);
        hullNext[n2] = n2;
        hullSize--;
        n2 = q;
      }
      if (e === start) {
        while (q = hullPrev[e], orient(x2, y2, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {
          t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
          this._legalize(t + 2);
          hullTri[q] = t;
          hullNext[e] = e;
          hullSize--;
          e = q;
        }
      }
      this._hullStart = hullPrev[i] = e;
      hullNext[e] = hullPrev[n2] = i;
      hullNext[i] = n2;
      hullHash[this._hashKey(x2, y2)] = i;
      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
    }
    this.hull = new Uint32Array(hullSize);
    for (let i = 0, e = this._hullStart; i < hullSize; i++) {
      this.hull[i] = e;
      e = hullNext[e];
    }
    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(x2, y2) {
    return Math.floor(pseudoAngle(x2 - this._cx, y2 - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(a2) {
    const { _triangles: triangles, _halfedges: halfedges, coords } = this;
    let i = 0;
    let ar = 0;
    while (true) {
      const b = halfedges[a2];
      const a0 = a2 - a2 % 3;
      ar = a0 + (a2 + 2) % 3;
      if (b === -1) {
        if (i === 0) break;
        a2 = EDGE_STACK[--i];
        continue;
      }
      const b0 = b - b % 3;
      const al = a0 + (a2 + 1) % 3;
      const bl = b0 + (b + 2) % 3;
      const p0 = triangles[ar];
      const pr = triangles[a2];
      const pl = triangles[al];
      const p1 = triangles[bl];
      const illegal = inCircle(
        coords[2 * p0],
        coords[2 * p0 + 1],
        coords[2 * pr],
        coords[2 * pr + 1],
        coords[2 * pl],
        coords[2 * pl + 1],
        coords[2 * p1],
        coords[2 * p1 + 1]
      );
      if (illegal) {
        triangles[a2] = p1;
        triangles[b] = p0;
        const hbl = halfedges[bl];
        if (hbl === -1) {
          let e = this._hullStart;
          do {
            if (this._hullTri[e] === bl) {
              this._hullTri[e] = a2;
              break;
            }
            e = this._hullPrev[e];
          } while (e !== this._hullStart);
        }
        this._link(a2, hbl);
        this._link(b, halfedges[ar]);
        this._link(ar, bl);
        const br = b0 + (b + 1) % 3;
        if (i < EDGE_STACK.length) {
          EDGE_STACK[i++] = br;
        }
      } else {
        if (i === 0) break;
        a2 = EDGE_STACK[--i];
      }
    }
    return ar;
  }
  _link(a2, b) {
    this._halfedges[a2] = b;
    if (b !== -1) this._halfedges[b] = a2;
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(i0, i1, i2, a2, b, c) {
    const t = this.trianglesLen;
    this._triangles[t] = i0;
    this._triangles[t + 1] = i1;
    this._triangles[t + 2] = i2;
    this._link(t, a2);
    this._link(t + 1, b);
    this._link(t + 2, c);
    this.trianglesLen += 3;
    return t;
  }
};
function pseudoAngle(dx, dy) {
  const p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function orientIfSure(px, py, rx, ry, qx, qy) {
  const l = (ry - py) * (qx - px);
  const r = (rx - px) * (qy - py);
  return Math.abs(l - r) >= 33306690738754716e-32 * Math.abs(l + r) ? l - r : 0;
}
function orient(rx, ry, qx, qy, px, py) {
  const sign3 = orientIfSure(px, py, rx, ry, qx, qy) || orientIfSure(rx, ry, qx, qy, px, py) || orientIfSure(qx, qy, px, py, rx, ry);
  return sign3 < 0;
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x2 = (ey * bl - dy * cl) * d;
  const y2 = (dx * cl - ex * bl) * d;
  return x2 * x2 + y2 * y2;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x2 = ax + (ey * bl - dy * cl) * d;
  const y2 = ay + (dx * cl - ex * bl) * d;
  return { x: x2, y: y2 };
}
function quicksort(ids, dists, left, right) {
  if (right - left <= 20) {
    for (let i = left + 1; i <= right; i++) {
      const temp = ids[i];
      const tempDist = dists[temp];
      let j = i - 1;
      while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
      ids[j + 1] = temp;
    }
  } else {
    const median = left + right >> 1;
    let i = left + 1;
    let j = right;
    swap2(ids, median, i);
    if (dists[ids[left]] > dists[ids[right]]) swap2(ids, left, right);
    if (dists[ids[i]] > dists[ids[right]]) swap2(ids, i, right);
    if (dists[ids[left]] > dists[ids[i]]) swap2(ids, left, i);
    const temp = ids[i];
    const tempDist = dists[temp];
    while (true) {
      do
        i++;
      while (dists[ids[i]] < tempDist);
      do
        j--;
      while (dists[ids[j]] > tempDist);
      if (j < i) break;
      swap2(ids, i, j);
    }
    ids[left + 1] = ids[j];
    ids[j] = temp;
    if (right - i + 1 >= j - left) {
      quicksort(ids, dists, i, right);
      quicksort(ids, dists, left, j - 1);
    } else {
      quicksort(ids, dists, left, j - 1);
      quicksort(ids, dists, i, right);
    }
  }
}
function swap2(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultGetX(p) {
  return p[0];
}
function defaultGetY(p) {
  return p[1];
}

// node_modules/d3-delaunay/src/path.js
var epsilon4 = 1e-6;
var Path2 = class {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
  }
  moveTo(x2, y2) {
    this._ += `M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x2, y2) {
    this._ += `L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  arc(x2, y2, r) {
    x2 = +x2, y2 = +y2, r = +r;
    const x0 = x2 + r;
    const y0 = y2;
    if (r < 0) throw new Error("negative radius");
    if (this._x1 === null) this._ += `M${x0},${y0}`;
    else if (Math.abs(this._x1 - x0) > epsilon4 || Math.abs(this._y1 - y0) > epsilon4) this._ += "L" + x0 + "," + y0;
    if (!r) return;
    this._ += `A${r},${r},0,1,1,${x2 - r},${y2}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
  }
  rect(x2, y2, w, h) {
    this._ += `M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${+w}v${+h}h${-w}Z`;
  }
  value() {
    return this._ || null;
  }
};

// node_modules/d3-delaunay/src/polygon.js
var Polygon = class {
  constructor() {
    this._ = [];
  }
  moveTo(x2, y2) {
    this._.push([x2, y2]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x2, y2) {
    this._.push([x2, y2]);
  }
  value() {
    return this._.length ? this._ : null;
  }
};

// node_modules/d3-delaunay/src/voronoi.js
var Voronoi = class {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const { delaunay: { points, hull, triangles }, vectors } = this;
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i = 0, j = 0, n = triangles.length, x2, y2; i < n; i += 3, j += 2) {
      const t13 = triangles[i] * 2;
      const t22 = triangles[i + 1] * 2;
      const t32 = triangles[i + 2] * 2;
      const x12 = points[t13];
      const y12 = points[t13 + 1];
      const x22 = points[t22];
      const y22 = points[t22 + 1];
      const x3 = points[t32];
      const y3 = points[t32 + 1];
      const dx = x22 - x12;
      const dy = y22 - y12;
      const ex = x3 - x12;
      const ey = y3 - y12;
      const bl = dx * dx + dy * dy;
      const cl = ex * ex + ey * ey;
      const ab = (dx * ey - dy * ex) * 2;
      if (!ab) {
        x2 = (x12 + x3) / 2 - 1e8 * ey;
        y2 = (y12 + y3) / 2 + 1e8 * ex;
      } else if (Math.abs(ab) < 1e-8) {
        x2 = (x12 + x3) / 2;
        y2 = (y12 + y3) / 2;
      } else {
        const d = 1 / ab;
        x2 = x12 + (ey * bl - dy * cl) * d;
        y2 = y12 + (dx * cl - ex * bl) * d;
      }
      circumcenters[j] = x2;
      circumcenters[j + 1] = y2;
    }
    let h = hull[hull.length - 1];
    let p0, p1 = h * 4;
    let x0, x1 = points[2 * h];
    let y0, y1 = points[2 * h + 1];
    vectors.fill(0);
    for (let i = 0; i < hull.length; ++i) {
      h = hull[i];
      p0 = p1, x0 = x1, y0 = y1;
      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
      vectors[p0 + 2] = vectors[p1] = y0 - y1;
      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
    }
  }
  render(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
    if (hull.length <= 1) return null;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i = 0; i < hull.length; ++i) {
      h0 = h1, h1 = hull[i];
      const t = Math.floor(inedges[h1] / 3) * 2;
      const x2 = circumcenters[t];
      const y2 = circumcenters[t + 1];
      const v = h0 * 4;
      const p = this._project(x2, y2, vectors[v + 2], vectors[v + 3]);
      if (p) this._renderSegment(x2, y2, p[0], p[1], context);
    }
    return buffer && buffer.value();
  }
  renderBounds(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i, context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const points = this._clip(i);
    if (points === null || !points.length) return;
    context.moveTo(points[0], points[1]);
    let n = points.length;
    while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1) n -= 2;
    for (let i2 = 2; i2 < n; i2 += 2) {
      if (points[i2] !== points[i2 - 2] || points[i2 + 1] !== points[i2 - 1])
        context.lineTo(points[i2], points[i2 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const { delaunay: { points } } = this;
    for (let i = 0, n = points.length / 2; i < n; ++i) {
      const cell = this.cellPolygon(i);
      if (cell) cell.index = i, yield cell;
    }
  }
  cellPolygon(i) {
    const polygon = new Polygon();
    this.renderCell(i, polygon);
    return polygon.value();
  }
  _renderSegment(x0, y0, x1, y1, context) {
    let S;
    const c0 = this._regioncode(x0, y0);
    const c1 = this._regioncode(x1, y1);
    if (c0 === 0 && c1 === 0) {
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
      context.moveTo(S[0], S[1]);
      context.lineTo(S[2], S[3]);
    }
  }
  contains(i, x2, y2) {
    if ((x2 = +x2, x2 !== x2) || (y2 = +y2, y2 !== y2)) return false;
    return this.delaunay._step(i, x2, y2) === i;
  }
  *neighbors(i) {
    const ci = this._clip(i);
    if (ci) for (const j of this.delaunay.neighbors(i)) {
      const cj = this._clip(j);
      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
          if (ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]) {
            yield j;
            break loop;
          }
        }
      }
    }
  }
  _cell(i) {
    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
    const e0 = inedges[i];
    if (e0 === -1) return null;
    const points = [];
    let e = e0;
    do {
      const t = Math.floor(e / 3);
      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break;
      e = halfedges[e];
    } while (e !== e0 && e !== -1);
    return points;
  }
  _clip(i) {
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points = this._cell(i);
    if (points === null) return null;
    const { vectors: V } = this;
    const v = i * 4;
    return V[v] || V[v + 1] ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3]) : this._clipFinite(i, points);
  }
  _clipFinite(i, points) {
    const n = points.length;
    let P = null;
    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
    let c0, c1 = this._regioncode(x1, y1);
    let e0, e1;
    for (let j = 0; j < n; j += 2) {
      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
      c0 = c1, c1 = this._regioncode(x1, y1);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P) P.push(x1, y1);
        else P = [x1, y1];
      } else {
        let S, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
          [sx0, sy0, sx1, sy1] = S;
        } else {
          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
          [sx1, sy1, sx0, sy0] = S;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
          if (P) P.push(sx0, sy0);
          else P = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        if (P) P.push(sx1, sy1);
        else P = [sx1, sy1];
      }
    }
    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1) this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P;
  }
  _clipSegment(x0, y0, x1, y1, c0, c1) {
    while (true) {
      if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
      if (c0 & c1) return null;
      let x2, y2, c = c0 || c1;
      if (c & 8) x2 = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y2 = this.ymax;
      else if (c & 4) x2 = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y2 = this.ymin;
      else if (c & 2) y2 = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x2 = this.xmax;
      else y2 = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x2 = this.xmin;
      if (c0) x0 = x2, y0 = y2, c0 = this._regioncode(x0, y0);
      else x1 = x2, y1 = y2, c1 = this._regioncode(x1, y1);
    }
  }
  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
    let P = Array.from(points), p;
    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
    if (P = this._clipFinite(i, P)) {
      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P;
  }
  _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      let x2, y2;
      switch (e0) {
        case 5:
          e0 = 4;
          continue;
        // top-left
        case 4:
          e0 = 6, x2 = this.xmax, y2 = this.ymin;
          break;
        // top
        case 6:
          e0 = 2;
          continue;
        // top-right
        case 2:
          e0 = 10, x2 = this.xmax, y2 = this.ymax;
          break;
        // right
        case 10:
          e0 = 8;
          continue;
        // bottom-right
        case 8:
          e0 = 9, x2 = this.xmin, y2 = this.ymax;
          break;
        // bottom
        case 9:
          e0 = 1;
          continue;
        // bottom-left
        case 1:
          e0 = 5, x2 = this.xmin, y2 = this.ymin;
          break;
      }
      if ((P[j] !== x2 || P[j + 1] !== y2) && this.contains(i, x2, y2)) {
        P.splice(j, 0, x2, y2), j += 2;
      }
    }
    if (P.length > 4) {
      for (let i2 = 0; i2 < P.length; i2 += 2) {
        const j2 = (i2 + 2) % P.length, k2 = (i2 + 4) % P.length;
        if (P[i2] === P[j2] && P[j2] === P[k2] || P[i2 + 1] === P[j2 + 1] && P[j2 + 1] === P[k2 + 1])
          P.splice(j2, 2), i2 -= 2;
      }
    }
    return j;
  }
  _project(x0, y0, vx, vy) {
    let t = Infinity, c, x2, y2;
    if (vy < 0) {
      if (y0 <= this.ymin) return null;
      if ((c = (this.ymin - y0) / vy) < t) y2 = this.ymin, x2 = x0 + (t = c) * vx;
    } else if (vy > 0) {
      if (y0 >= this.ymax) return null;
      if ((c = (this.ymax - y0) / vy) < t) y2 = this.ymax, x2 = x0 + (t = c) * vx;
    }
    if (vx > 0) {
      if (x0 >= this.xmax) return null;
      if ((c = (this.xmax - x0) / vx) < t) x2 = this.xmax, y2 = y0 + (t = c) * vy;
    } else if (vx < 0) {
      if (x0 <= this.xmin) return null;
      if ((c = (this.xmin - x0) / vx) < t) x2 = this.xmin, y2 = y0 + (t = c) * vy;
    }
    return [x2, y2];
  }
  _edgecode(x2, y2) {
    return (x2 === this.xmin ? 1 : x2 === this.xmax ? 2 : 0) | (y2 === this.ymin ? 4 : y2 === this.ymax ? 8 : 0);
  }
  _regioncode(x2, y2) {
    return (x2 < this.xmin ? 1 : x2 > this.xmax ? 2 : 0) | (y2 < this.ymin ? 4 : y2 > this.ymax ? 8 : 0);
  }
};

// node_modules/d3-delaunay/src/delaunay.js
var tau3 = 2 * Math.PI;
var pow2 = Math.pow;
function pointX(p) {
  return p[0];
}
function pointY(p) {
  return p[1];
}
function collinear(d) {
  const { triangles, coords } = d;
  for (let i = 0; i < triangles.length; i += 3) {
    const a2 = 2 * triangles[i], b = 2 * triangles[i + 1], c = 2 * triangles[i + 2], cross2 = (coords[c] - coords[a2]) * (coords[b + 1] - coords[a2 + 1]) - (coords[b] - coords[a2]) * (coords[c + 1] - coords[a2 + 1]);
    if (cross2 > 1e-10) return false;
  }
  return true;
}
function jitter(x2, y2, r) {
  return [x2 + Math.sin(x2 + y2) * r, y2 + Math.cos(x2 - y2) * r];
}
var Delaunay = class _Delaunay {
  static from(points, fx = pointX, fy = pointY, that) {
    return new _Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
  }
  constructor(points) {
    this._delaunator = new Delaunator(points);
    this.inedges = new Int32Array(points.length / 2);
    this._hullIndex = new Int32Array(points.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points = this.points;
    if (d.hull && d.hull.length > 2 && collinear(d)) {
      this.collinear = Int32Array.from({ length: points.length / 2 }, (_, i) => i).sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]);
      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds = [points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1]], r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
      for (let i = 0, n = points.length / 2; i < n; ++i) {
        const p = jitter(points[2 * i], points[2 * i + 1], r);
        points[2 * i] = p[0];
        points[2 * i + 1] = p[1];
      }
      this._delaunator = new Delaunator(points);
    } else {
      delete this.collinear;
    }
    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);
    for (let e = 0, n = halfedges.length; e < n; ++e) {
      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
    }
    for (let i = 0, n = hull.length; i < n; ++i) {
      hullIndex[hull[i]] = i;
    }
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      this.triangles[1] = hull[1];
      this.triangles[2] = hull[1];
      inedges[hull[0]] = 1;
      if (hull.length === 2) inedges[hull[1]] = 0;
    }
  }
  voronoi(bounds) {
    return new Voronoi(this, bounds);
  }
  *neighbors(i) {
    const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear2 } = this;
    if (collinear2) {
      const l = collinear2.indexOf(i);
      if (l > 0) yield collinear2[l - 1];
      if (l < collinear2.length - 1) yield collinear2[l + 1];
      return;
    }
    const e0 = inedges[i];
    if (e0 === -1) return;
    let e = e0, p0 = -1;
    do {
      yield p0 = triangles[e];
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) return;
      e = halfedges[e];
      if (e === -1) {
        const p = hull[(_hullIndex[i] + 1) % hull.length];
        if (p !== p0) yield p;
        return;
      }
    } while (e !== e0);
  }
  find(x2, y2, i = 0) {
    if ((x2 = +x2, x2 !== x2) || (y2 = +y2, y2 !== y2)) return -1;
    const i0 = i;
    let c;
    while ((c = this._step(i, x2, y2)) >= 0 && c !== i && c !== i0) i = c;
    return c;
  }
  _step(i, x2, y2) {
    const { inedges, hull, _hullIndex, halfedges, triangles, points } = this;
    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
    let c = i;
    let dc = pow2(x2 - points[i * 2], 2) + pow2(y2 - points[i * 2 + 1], 2);
    const e0 = inedges[i];
    let e = e0;
    do {
      let t = triangles[e];
      const dt = pow2(x2 - points[t * 2], 2) + pow2(y2 - points[t * 2 + 1], 2);
      if (dt < dc) dc = dt, c = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break;
      e = halfedges[e];
      if (e === -1) {
        e = hull[(_hullIndex[i] + 1) % hull.length];
        if (e !== t) {
          if (pow2(x2 - points[e * 2], 2) + pow2(y2 - points[e * 2 + 1], 2) < dc) return e;
        }
        break;
      }
    } while (e !== e0);
    return c;
  }
  render(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { points, halfedges, triangles } = this;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = triangles[i] * 2;
      const tj = triangles[j] * 2;
      context.moveTo(points[ti], points[ti + 1]);
      context.lineTo(points[tj], points[tj + 1]);
    }
    this.renderHull(context);
    return buffer && buffer.value();
  }
  renderPoints(context, r = 2) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { points } = this;
    for (let i = 0, n = points.length; i < n; i += 2) {
      const x2 = points[i], y2 = points[i + 1];
      context.moveTo(x2 + r, y2);
      context.arc(x2, y2, r, 0, tau3);
    }
    return buffer && buffer.value();
  }
  renderHull(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { hull, points } = this;
    const h = hull[0] * 2, n = hull.length;
    context.moveTo(points[h], points[h + 1]);
    for (let i = 1; i < n; ++i) {
      const h2 = 2 * hull[i];
      context.lineTo(points[h2], points[h2 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon = new Polygon();
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i, context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { points, triangles } = this;
    const t03 = triangles[i *= 3] * 2;
    const t13 = triangles[i + 1] * 2;
    const t22 = triangles[i + 2] * 2;
    context.moveTo(points[t03], points[t03 + 1]);
    context.lineTo(points[t13], points[t13 + 1]);
    context.lineTo(points[t22], points[t22 + 1]);
    context.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const { triangles } = this;
    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
      yield this.trianglePolygon(i);
    }
  }
  trianglePolygon(i) {
    const polygon = new Polygon();
    this.renderTriangle(i, polygon);
    return polygon.value();
  }
};
function flatArray(points, fx, fy, that) {
  const n = points.length;
  const array2 = new Float64Array(n * 2);
  for (let i = 0; i < n; ++i) {
    const p = points[i];
    array2[i * 2] = fx.call(that, p, i, points);
    array2[i * 2 + 1] = fy.call(that, p, i, points);
  }
  return array2;
}
function* flatIterable(points, fx, fy, that) {
  let i = 0;
  for (const p of points) {
    yield fx.call(that, p, i, points);
    yield fy.call(that, p, i, points);
    ++i;
  }
}

// node_modules/react-charts/es/components/Voronoi.js
function Voronoi2() {
  var _useChartContext = useChartContext(), getOptions = _useChartContext.getOptions, focusedDatumState = _useChartContext.focusedDatumState, isInteractingState = _useChartContext.isInteractingState;
  var setFocusedDatum = focusedDatumState[1];
  var isInteracting = isInteractingState[0];
  var _getOptions = getOptions(), onFocusDatum = _getOptions.onFocusDatum, onClickDatum = _getOptions.onClickDatum, tooltip = _getOptions.tooltip, primaryCursor = _getOptions.primaryCursor, secondaryCursor = _getOptions.secondaryCursor, showVoronoi = _getOptions.showVoronoi, interactionMode = _getOptions.interactionMode;
  var handleFocus = import_react15.default.useCallback(function(datum) {
    var _getOptions$onFocusDa, _getOptions2;
    (_getOptions$onFocusDa = (_getOptions2 = getOptions()).onFocusDatum) == null ? void 0 : _getOptions$onFocusDa.call(_getOptions2, datum);
    setFocusedDatum(datum);
  }, [getOptions, setFocusedDatum]);
  var needsVoronoi = isInteracting && (showVoronoi || onFocusDatum || onClickDatum || tooltip || primaryCursor || secondaryCursor);
  if (!needsVoronoi) {
    return null;
  }
  var props = {
    handleFocus
  };
  if (interactionMode === "closest") {
    return import_react15.default.createElement(SingleVoronoi, props);
  }
  return import_react15.default.createElement(PrimaryVoronoi, props);
}
function PrimaryVoronoi(_ref) {
  var handleFocus = _ref.handleFocus;
  var _useChartContext2 = useChartContext(), primaryAxis = _useChartContext2.primaryAxis, secondaryAxes = _useChartContext2.secondaryAxes, getOptions = _useChartContext2.getOptions, gridDimensions = _useChartContext2.gridDimensions, datumsByInteractionGroup = _useChartContext2.datumsByInteractionGroup;
  var stackedVoronoi = secondaryAxes.length === 1 && secondaryAxes[0].stacked;
  var useBarPx = secondaryAxes.every(function(d) {
    return d.elementType === "bar" && !d.stacked;
  });
  return import_react15.default.useMemo(function() {
    var preColumns = Array.from(datumsByInteractionGroup.entries()).map(function(_ref2) {
      var _ = _ref2[0], datums = _ref2[1];
      return datums;
    }).filter(function(datums) {
      var datum = datums[0];
      if (!datum) {
        return;
      }
      var primaryValue = datum.primaryValue;
      return primaryValue !== "undefined" && primaryValue !== null;
    }).sort(function(a2, b) {
      var aAxis = secondaryAxes.find(function(d) {
        return d.id === a2[0].secondaryAxisId;
      });
      var bAxis = secondaryAxes.find(function(d) {
        return d.id === b[0].secondaryAxisId;
      });
      var aPx = getPrimary3(a2[0], primaryAxis, aAxis, useBarPx);
      var bPx = getPrimary3(b[0], primaryAxis, bAxis, useBarPx);
      return aPx - bPx;
    });
    if (primaryAxis.isVertical) {
      preColumns.reverse();
    }
    var columns = preColumns.map(function(datums, i, all) {
      var _primaryAxis$scale$ra;
      var datum = datums[0];
      var prev = all[i - 1];
      var next = all[i + 1];
      var secondaryAxis = secondaryAxes.find(function(d) {
        return d.id === datum.secondaryAxisId;
      });
      var primaryPx = getPrimary3(datum, primaryAxis, secondaryAxis, useBarPx);
      var range = (_primaryAxis$scale$ra = primaryAxis == null ? void 0 : primaryAxis.scale.range()) != null ? _primaryAxis$scale$ra : [0, 0];
      var primaryStart = range[0], primaryEnd = range[1];
      if (prev) {
        var _secondaryAxis = secondaryAxes.find(function(d) {
          return d.id === prev[0].secondaryAxisId;
        });
        var prevPx = getPrimary3(prev[0], primaryAxis, _secondaryAxis, useBarPx);
        primaryStart = primaryPx - (primaryPx - prevPx) / 2;
      }
      if (next) {
        var _secondaryAxis2 = secondaryAxes.find(function(d) {
          return d.id === next[0].secondaryAxisId;
        });
        var nextPx = getPrimary3(next[0], primaryAxis, _secondaryAxis2, useBarPx);
        primaryEnd = primaryPx + (nextPx - primaryPx) / 2;
      }
      return {
        primaryStart,
        primaryEnd,
        primaryPx,
        datumBoundaries: datums.filter(function(datum2) {
          var secondaryValue = datum2.secondaryValue;
          return typeof secondaryValue !== "undefined" && secondaryValue !== null;
        }).map(function(datum2, i2, all2) {
          var _secondaryAxis$scale3, _datum$stackData3, _secondaryAxis$scale$2;
          var prev2 = all2[i2 - 1];
          var next2 = all2[i2 + 1];
          var secondaryAxis2 = secondaryAxes.find(function(d) {
            return d.id === datum2.secondaryAxisId;
          });
          if (stackedVoronoi) {
            var _secondaryAxis$scale$, _datum$stackData, _datum$stackData2;
            var _range = (_secondaryAxis$scale$ = secondaryAxis2 == null ? void 0 : secondaryAxis2.scale.range()) != null ? _secondaryAxis$scale$ : [0, 0];
            var stackData = [(_datum$stackData = datum2.stackData) == null ? void 0 : _datum$stackData[0], (_datum$stackData2 = datum2.stackData) == null ? void 0 : _datum$stackData2[1]];
            if (secondaryAxis2 != null && secondaryAxis2.isVertical) {
              _range.reverse();
              stackData.reverse();
            }
            var _secondaryStart = _range[0], _secondaryEnd = _range[1];
            if (prev2) {
              var _secondaryAxis$scale, _stackData$;
              _secondaryStart = (_secondaryAxis$scale = secondaryAxis2 == null ? void 0 : secondaryAxis2.scale((_stackData$ = stackData[0]) != null ? _stackData$ : NaN)) != null ? _secondaryAxis$scale : NaN;
            }
            if (next2) {
              var _secondaryAxis$scale2, _stackData$2;
              _secondaryEnd = (_secondaryAxis$scale2 = secondaryAxis2 == null ? void 0 : secondaryAxis2.scale((_stackData$2 = stackData[1]) != null ? _stackData$2 : NaN)) != null ? _secondaryAxis$scale2 : NaN;
            }
            return {
              secondaryStart: _secondaryStart,
              secondaryEnd: _secondaryEnd,
              datum: datum2
            };
          }
          var value = (_secondaryAxis$scale3 = secondaryAxis2 == null ? void 0 : secondaryAxis2.scale(secondaryAxis2.stacked ? (_datum$stackData3 = datum2.stackData) == null ? void 0 : _datum$stackData3[1] : datum2.secondaryValue)) != null ? _secondaryAxis$scale3 : NaN;
          var range2 = (_secondaryAxis$scale$2 = secondaryAxis2 == null ? void 0 : secondaryAxis2.scale.range()) != null ? _secondaryAxis$scale$2 : [0, 0];
          if (secondaryAxis2 != null && secondaryAxis2.isVertical) {
            range2.reverse();
          }
          var secondaryStart = range2[0], secondaryEnd = range2[1];
          if (prev2) {
            var _prevAxis$scale, _prev$stackData;
            var prevAxis = secondaryAxes.find(function(d) {
              return d.id === (prev2 == null ? void 0 : prev2.secondaryAxisId);
            });
            var prevValue = (_prevAxis$scale = prevAxis == null ? void 0 : prevAxis.scale(prevAxis.stacked ? (_prev$stackData = prev2.stackData) == null ? void 0 : _prev$stackData[1] : prev2.secondaryValue)) != null ? _prevAxis$scale : NaN;
            secondaryStart = value - (value - prevValue) / 2;
          }
          if (next2) {
            var _nextAxis$scale, _next$stackData;
            var nextAxis = secondaryAxes.find(function(d) {
              return d.id === (next2 == null ? void 0 : next2.secondaryAxisId);
            });
            var nextValue = (_nextAxis$scale = nextAxis == null ? void 0 : nextAxis.scale(nextAxis.stacked ? (_next$stackData = next2.stackData) == null ? void 0 : _next$stackData[1] : next2.secondaryValue)) != null ? _nextAxis$scale : NaN;
            secondaryEnd = value + (nextValue - value) / 2;
          }
          return {
            secondaryStart,
            secondaryEnd,
            datum: datum2
          };
        })
      };
    });
    return import_react15.default.createElement("g", {
      onMouseLeave: function onMouseLeave() {
        return handleFocus(null);
      },
      style: {
        transform: translate(gridDimensions.left, gridDimensions.top)
      }
    }, columns.map(function(column, i) {
      return import_react15.default.createElement("g", {
        key: column.primaryPx + "_" + i
      }, column.datumBoundaries.map(function(datumBoundary, i2) {
        var x1 = !primaryAxis.isVertical ? column.primaryStart : datumBoundary.secondaryStart;
        var x2 = !primaryAxis.isVertical ? column.primaryEnd : datumBoundary.secondaryEnd;
        var y1 = !primaryAxis.isVertical ? datumBoundary.secondaryStart : column.primaryStart;
        var y2 = !primaryAxis.isVertical ? datumBoundary.secondaryEnd : column.primaryEnd;
        var x3 = Math.min(x1, x2);
        var y3 = Math.min(y1, y2);
        var xEnd = Math.max(x1, x2);
        var yEnd = Math.max(y1, y2);
        var height = Math.max(yEnd - y3, 0);
        var width = Math.max(xEnd - x3, 0);
        return import_react15.default.createElement("rect", {
          key: i2,
          x: x3,
          y: y3,
          width,
          height,
          className: "action-voronoi",
          onMouseEnter: function onMouseEnter() {
            return handleFocus(datumBoundary.datum);
          },
          style: {
            fill: getOptions().dark ? "#ffffff33" : "rgba(0,0,0,0.2)",
            strokeWidth: 1,
            stroke: getOptions().dark ? "white" : "black",
            opacity: getOptions().showVoronoi ? 1 : 0
          }
        });
      }));
    }));
  }, [datumsByInteractionGroup, primaryAxis, gridDimensions.left, gridDimensions.top, secondaryAxes, useBarPx, stackedVoronoi, handleFocus, getOptions]);
}
var delaunayLineFn = line_default();
function SingleVoronoi(_ref3) {
  var handleFocus = _ref3.handleFocus;
  var _useChartContext3 = useChartContext(), primaryAxis = _useChartContext3.primaryAxis, series = _useChartContext3.series, secondaryAxes = _useChartContext3.secondaryAxes, getOptions = _useChartContext3.getOptions, gridDimensions = _useChartContext3.gridDimensions;
  var polygons = null;
  var voronoiData = [];
  var useBarPx = secondaryAxes.every(function(d) {
    return d.elementType === "bar" && !d.stacked;
  });
  series.forEach(function(serie) {
    serie.datums.filter(function(datum) {
      var primaryValue = datum.primaryValue;
      var secondaryValue = datum.secondaryValue;
      return primaryValue !== "undefined" && primaryValue !== null && secondaryValue !== "undefined" && secondaryValue !== null;
    }).forEach(function(datum) {
      var secondaryAxis = secondaryAxes.find(function(d) {
        return d.id === datum.secondaryAxisId;
      });
      var x2 = getX2(datum, primaryAxis, secondaryAxis, useBarPx);
      var y2 = getY2(datum, primaryAxis, secondaryAxis, useBarPx);
      if (typeof x2 !== "number" || typeof y2 !== "number" || Number.isNaN(y2) || Number.isNaN(x2)) {
        return;
      }
      voronoiData.push({
        x: x2,
        y: y2,
        datum
      });
    });
  });
  var delaunay = Delaunay.from(voronoiData, function(d) {
    return Math.max(d.x, 0);
  }, function(d) {
    return Math.max(d.y, 0);
  });
  var voronoi = delaunay.voronoi([0, 0, gridDimensions.width, gridDimensions.height]);
  polygons = voronoi.cellPolygons();
  polygons = Array.from(polygons);
  return import_react15.default.createElement("g", {
    onMouseLeave: function onMouseLeave() {
      return handleFocus(null);
    },
    style: {
      transform: translate(gridDimensions.left, gridDimensions.top)
    }
  }, polygons.map(function(points, i) {
    var index2 = points.index;
    var datum = voronoiData[index2].datum;
    var path2 = delaunayLineFn(points) || void 0;
    return import_react15.default.createElement("path", {
      key: i,
      d: path2,
      className: "action-voronoi",
      onMouseEnter: function onMouseEnter() {
        return handleFocus(datum);
      },
      style: {
        fill: getOptions().dark ? "#ffffff33" : "rgba(0,0,0,0.2)",
        strokeWidth: 1,
        stroke: getOptions().dark ? "white" : "black",
        opacity: getOptions().showVoronoi ? 1 : 0
      }
    });
  }));
}
function getX2(datum, primaryAxis, secondaryAxis, useBarPx) {
  return primaryAxis.isVertical ? getSecondary3(datum, secondaryAxis) : getPrimary3(datum, primaryAxis, secondaryAxis, useBarPx);
}
function getY2(datum, primaryAxis, secondaryAxis, useBarPx) {
  return primaryAxis.isVertical ? getPrimary3(datum, primaryAxis, secondaryAxis, useBarPx) : getSecondary3(datum, secondaryAxis);
}
function getPrimary3(datum, primaryAxis, secondaryAxis, useBarPx) {
  var _primaryAxis$scale;
  var primary = (_primaryAxis$scale = primaryAxis.scale(datum.primaryValue)) != null ? _primaryAxis$scale : NaN;
  if (useBarPx && secondaryAxis.elementType === "bar") {
    if (!secondaryAxis.stacked) {
      var _ref4;
      primary += (_ref4 = primaryAxis.seriesBandScale(datum.seriesIndex)) != null ? _ref4 : NaN;
      primary += getPrimaryLength(datum, primaryAxis, secondaryAxis) / 2;
    } else {
      primary += getPrimaryGroupLength(datum, primaryAxis) / 2;
    }
  }
  return primary;
}
function getSecondary3(datum, secondaryAxis) {
  var _secondaryAxis$scale5;
  if (secondaryAxis.stacked) {
    var _secondaryAxis$scale4, _datum$stackData$, _datum$stackData4;
    return (_secondaryAxis$scale4 = secondaryAxis.scale((_datum$stackData$ = (_datum$stackData4 = datum.stackData) == null ? void 0 : _datum$stackData4[1]) != null ? _datum$stackData$ : NaN)) != null ? _secondaryAxis$scale4 : NaN;
  }
  return (_secondaryAxis$scale5 = secondaryAxis.scale(datum.secondaryValue)) != null ? _secondaryAxis$scale5 : NaN;
}

// node_modules/react-charts/es/components/Chart.js
var _excluded2 = ["options", "className", "style"];
var defaultColorScheme = ["#0f83ab", "#faa43a", "#fd6868", "#53cfc9", "#a2d925", "#decf3f", "#734fe9", "#cd82ad", "#006d92", "#de7c00", "#f33232", "#3f9a80", "#53c200", "#d7af00", "#4c26c9", "#d44d99"];
var defaultPadding = 5;
function defaultChartOptions(options) {
  var _options$initialWidth, _options$initialHeigh, _options$getSeriesOrd, _options$interactionM, _options$showVoronoi, _options$defaultColor, _options$useIntersect, _options$intersection, _options$primaryCurso, _options$secondaryCur, _options$padding;
  return _extends({}, options, {
    initialWidth: (_options$initialWidth = options.initialWidth) != null ? _options$initialWidth : 300,
    initialHeight: (_options$initialHeigh = options.initialHeight) != null ? _options$initialHeigh : 200,
    getSeriesOrder: (_options$getSeriesOrd = options.getSeriesOrder) != null ? _options$getSeriesOrd : function(series) {
      return series;
    },
    interactionMode: (_options$interactionM = options.interactionMode) != null ? _options$interactionM : "primary",
    showVoronoi: (_options$showVoronoi = options.showVoronoi) != null ? _options$showVoronoi : false,
    defaultColors: (_options$defaultColor = options.defaultColors) != null ? _options$defaultColor : defaultColorScheme,
    useIntersectionObserver: (_options$useIntersect = options.useIntersectionObserver) != null ? _options$useIntersect : false,
    intersectionObserverRootMargin: (_options$intersection = options.intersectionObserverRootMargin) != null ? _options$intersection : "1000px",
    primaryCursor: (_options$primaryCurso = options.primaryCursor) != null ? _options$primaryCurso : true,
    secondaryCursor: (_options$secondaryCur = options.secondaryCursor) != null ? _options$secondaryCur : true,
    padding: (_options$padding = options.padding) != null ? _options$padding : defaultPadding
  });
}
function Chart(_ref) {
  var userOptions = _ref.options, className = _ref.className, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, rest = _objectWithoutPropertiesLoose(_ref, _excluded2);
  var options = defaultChartOptions(userOptions);
  var _React$useState = import_react16.default.useState(null), chartElement = _React$useState[0], setContainerElement = _React$useState[1];
  var containerEl = chartElement == null ? void 0 : chartElement.parentElement;
  var nearestScrollableParent = import_react16.default.useMemo(function() {
    var run = function run2(el) {
      if (!el) {
        return null;
      }
      var grandParent = el.parentElement;
      if (!grandParent) {
        return null;
      }
      if (grandParent.scrollHeight > grandParent.clientHeight) {
        var _window$getComputedSt = window.getComputedStyle(grandParent), overflow = _window$getComputedSt.overflow;
        if (overflow.includes("scroll") || overflow.includes("auto")) {
          return grandParent;
        }
      }
      return run2(grandParent);
    };
    return run(containerEl);
  }, [containerEl]);
  var _React$useState2 = import_react16.default.useState({
    width: options.initialWidth,
    height: options.initialHeight
  }), _React$useState2$ = _React$useState2[0], width = _React$useState2$.width, height = _React$useState2$.height, setDims = _React$useState2[1];
  useIsomorphicLayoutEffect_default(function() {
    if (containerEl) {
      var computed = window.getComputedStyle(containerEl);
      if (!["relative", "absolute", "fixed"].includes(computed.position)) {
        containerEl.style.position = "relative";
      }
    }
  }, [containerEl]);
  import_react16.default.useEffect(function() {
    if (!containerEl) {
      return;
    }
    var observer = new ResizeObserver(function() {
      var rect = containerEl == null ? void 0 : containerEl.getBoundingClientRect();
      var styles = window.getComputedStyle(containerEl);
      if (rect) {
        setDims({
          width: rect.width - parseInt(styles.borderLeftWidth) - parseInt(styles.borderRightWidth),
          height: rect.height - parseInt(styles.borderTopWidth) - parseInt(styles.borderBottomWidth)
        });
      }
    });
    observer.observe(containerEl);
    return function() {
      observer.unobserve(containerEl);
    };
  }, [containerEl]);
  var _React$useState3 = import_react16.default.useState(true), isIntersecting = _React$useState3[0], setIsIntersecting = _React$useState3[1];
  import_react16.default.useEffect(function() {
    if (!containerEl || !options.useIntersectionObserver) return;
    var observer = new IntersectionObserver(function(entries) {
      for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done; ) {
        var entry = _step.value;
        if (entry.isIntersecting) {
          setIsIntersecting(true);
        } else {
          setIsIntersecting(false);
        }
      }
    }, {
      root: nearestScrollableParent,
      rootMargin: options.intersectionObserverRootMargin
    });
    observer.observe(containerEl);
    return function() {
      observer.unobserve(containerEl);
    };
  }, [containerEl, nearestScrollableParent, options.intersectionObserverRootMargin, options.useIntersectionObserver]);
  return import_react16.default.createElement("div", _extends({
    ref: setContainerElement
  }, rest, {
    className: "ReactChart " + (className || ""),
    style: _extends({
      fontFamily: "sans-serif"
    }, style, {
      position: "absolute",
      width,
      height
    })
  }), options.useIntersectionObserver && !isIntersecting ? null : import_react16.default.createElement(ChartInner, {
    options,
    width,
    height
  }));
}
function ChartInner(_ref2) {
  var _options2, _options$renderSVG;
  var options = _ref2.options, width = _ref2.width, height = _ref2.height;
  if (!options.primaryAxis) {
    throw new Error("A primaryAxis is required");
  }
  if (!options.secondaryAxes.length) {
    throw new Error("At least one secondaryAxis is required");
  }
  var primaryAxisOptions = import_react16.default.useMemo(function() {
    var firstValue = getFirstDefinedValue(options.primaryAxis, options.data);
    var axisOptions = axisOptionsWithScaleType(options.primaryAxis, firstValue);
    return _extends({
      position: "bottom"
    }, axisOptions);
  }, [options.data, options.primaryAxis]);
  var secondaryAxesOptions = import_react16.default.useMemo(function() {
    return options.secondaryAxes.map(function(secondaryAxis, i) {
      var firstValue = getFirstDefinedValue(secondaryAxis, options.data);
      var axisOptions = axisOptionsWithScaleType(secondaryAxis, firstValue);
      if (!axisOptions.elementType) {
        if (primaryAxisOptions.scaleType === "band") {
          axisOptions.elementType = "bar";
        } else if (axisOptions.stacked) {
          axisOptions.elementType = "area";
        }
      }
      if (typeof axisOptions.stacked === "undefined" && axisOptions.elementType && ["area"].includes(axisOptions.elementType)) {
        axisOptions.stacked = true;
      }
      return _extends({
        position: !i ? "left" : "right"
      }, axisOptions);
    });
  }, [options.data, options.secondaryAxes, primaryAxisOptions]);
  var tooltipOptions = import_react16.default.useMemo(function() {
    var _options, _tooltipOptions$group;
    var tooltipOptions2 = defaultTooltip((_options = options) == null ? void 0 : _options.tooltip);
    tooltipOptions2.groupingMode = (_tooltipOptions$group = tooltipOptions2.groupingMode) != null ? _tooltipOptions$group : function() {
      if (options.interactionMode === "closest") {
        return "single";
      }
      return "primary";
    }();
    return tooltipOptions2;
  }, [options.interactionMode, (_options2 = options) == null ? void 0 : _options2.tooltip]);
  options = _extends({}, options, {
    tooltip: tooltipOptions
  });
  var svgRef = import_react16.default.useRef(null);
  var getOptions = useGetLatest(_extends({}, options, {
    tooltip: tooltipOptions
  }));
  var axisDimensionsState = import_react16.default.useState({
    left: {},
    right: {},
    top: {},
    bottom: {}
  });
  var axisDimensions = axisDimensionsState[0];
  var isInteractingState = import_react16.default.useState(false);
  var isInteracting = isInteractingState[0];
  var focusedDatumState = import_react16.default.useState(null);
  var focusedDatum = focusedDatumState[0];
  var gridDimensions = import_react16.default.useMemo(function() {
    var _options$padding$left, _options$padding$righ, _options$padding$bott, _options$padding$top;
    var padding = {
      left: typeof options.padding === "object" ? (_options$padding$left = options.padding.left) != null ? _options$padding$left : defaultPadding : options.padding,
      right: typeof options.padding === "object" ? (_options$padding$righ = options.padding.right) != null ? _options$padding$righ : defaultPadding : options.padding,
      bottom: typeof options.padding === "object" ? (_options$padding$bott = options.padding.bottom) != null ? _options$padding$bott : defaultPadding : options.padding,
      top: typeof options.padding === "object" ? (_options$padding$top = options.padding.top) != null ? _options$padding$top : defaultPadding : options.padding
    };
    var left = padding.left + Math.max(sum(Object.values(axisDimensions.left), function(d) {
      return d.width;
    }), sum(Object.values(axisDimensions.top), function(d) {
      return d.paddingLeft;
    }), sum(Object.values(axisDimensions.bottom), function(d) {
      return d.paddingLeft;
    }));
    var top = padding.top + Math.max(sum(Object.values(axisDimensions.top), function(d) {
      return d.height;
    }), sum(Object.values(axisDimensions.left), function(d) {
      return d.paddingTop;
    }), sum(Object.values(axisDimensions.right), function(d) {
      return d.paddingTop;
    }));
    var right = padding.right + Math.max(sum(Object.values(axisDimensions.right), function(d) {
      return d.width;
    }), sum(Object.values(axisDimensions.top), function(d) {
      return d.paddingRight;
    }), sum(Object.values(axisDimensions.bottom), function(d) {
      return d.paddingRight;
    }));
    var bottom = padding.bottom + Math.max(sum(Object.values(axisDimensions.bottom), function(d) {
      return d.height;
    }), sum(Object.values(axisDimensions.left), function(d) {
      return d.paddingBottom;
    }), sum(Object.values(axisDimensions.right), function(d) {
      return d.paddingBottom;
    }));
    var gridWidth = Math.max(0, width - left - right);
    var gridHeight = Math.max(0, height - top - bottom);
    return {
      left,
      top,
      right,
      bottom,
      width: gridWidth,
      height: gridHeight
    };
  }, [options.padding, axisDimensions.left, axisDimensions.top, axisDimensions.bottom, axisDimensions.right, width, height]);
  var series = import_react16.default.useMemo(function() {
    var series2 = [];
    var indicesByAxisId = {};
    for (var seriesIndex = 0; seriesIndex < options.data.length; seriesIndex++) {
      var _originalSeries$id, _originalSeries$label, _indicesByAxisId$;
      var originalSeries = options.data[seriesIndex];
      var seriesId = (_originalSeries$id = originalSeries.id) != null ? _originalSeries$id : seriesIndex + "";
      var seriesLabel = (_originalSeries$label = originalSeries.label) != null ? _originalSeries$label : "Series " + (seriesIndex + 1);
      var secondaryAxisId = originalSeries.secondaryAxisId;
      var originalDatums = originalSeries.data;
      var datums = [];
      indicesByAxisId["" + secondaryAxisId] = (_indicesByAxisId$ = indicesByAxisId["" + secondaryAxisId]) != null ? _indicesByAxisId$ : 0;
      var seriesIndexPerAxis = indicesByAxisId["" + secondaryAxisId];
      indicesByAxisId["" + secondaryAxisId]++;
      for (var datumIndex = 0; datumIndex < originalDatums.length; datumIndex++) {
        var originalDatum = originalDatums[datumIndex];
        datums[datumIndex] = {
          originalSeries,
          seriesIndex,
          seriesIndexPerAxis,
          seriesId,
          seriesLabel,
          secondaryAxisId,
          index: datumIndex,
          originalDatum
        };
      }
      series2[seriesIndex] = {
        originalSeries,
        index: seriesIndex,
        id: seriesId,
        label: seriesLabel,
        indexPerAxis: seriesIndexPerAxis,
        secondaryAxisId,
        datums
      };
    }
    return series2;
  }, [options.data]);
  var allDatums = import_react16.default.useMemo(function() {
    return series.map(function(s2) {
      return s2.datums;
    }).flat(2);
  }, [series]);
  var primaryAxis = import_react16.default.useMemo(function() {
    return buildAxisLinear(true, primaryAxisOptions, series, allDatums, gridDimensions, width, height);
  }, [allDatums, gridDimensions, height, primaryAxisOptions, series, width]);
  var secondaryAxes = import_react16.default.useMemo(function() {
    return secondaryAxesOptions.map(function(secondaryAxis) {
      return buildAxisLinear(false, secondaryAxis, series, allDatums, gridDimensions, width, height);
    });
  }, [allDatums, gridDimensions, height, secondaryAxesOptions, series, width]);
  var _React$useMemo = import_react16.default.useMemo(function() {
    if (!isInteracting) {
      return [/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()];
    }
    var datumsByInteractionGroup2 = /* @__PURE__ */ new Map();
    var datumsByTooltipGroup2 = /* @__PURE__ */ new Map();
    var allBarAndNotStacked = secondaryAxes.every(function(d) {
      return d.elementType === "bar" && !d.stacked;
    });
    var getInteractionPrimary = function getInteractionPrimary2(datum) {
      if (allBarAndNotStacked) {
        var secondaryAxis = secondaryAxes.find(function(d) {
          return d.id === datum.secondaryAxisId;
        });
        if (secondaryAxis.elementType === "bar" && !secondaryAxis.stacked) {
          return getPrimary(datum, primaryAxis, secondaryAxis);
        }
      }
      return datum.primaryValue;
    };
    var getInteractionKey = function getInteractionKey2(datum) {
      return "" + getInteractionPrimary(datum);
    };
    var getTooltipKey = function getTooltipKey2(datum) {
      return "" + datum.primaryValue;
    };
    if (options.interactionMode === "closest") {
      getInteractionKey = function getInteractionKey2(datum) {
        return getInteractionPrimary(datum) + "_" + datum.secondaryValue;
      };
    }
    if (tooltipOptions.groupingMode === "single") {
      getTooltipKey = function getTooltipKey2(datum) {
        return datum.primaryValue + "_" + datum.secondaryValue;
      };
    } else if (tooltipOptions.groupingMode === "secondary") {
      getTooltipKey = function getTooltipKey2(datum) {
        return "" + datum.secondaryValue;
      };
    } else if (tooltipOptions.groupingMode === "series") {
      getTooltipKey = function getTooltipKey2(datum) {
        return "" + datum.seriesIndex;
      };
    }
    allDatums.forEach(function(datum) {
      var interactionKey = getInteractionKey(datum);
      var tooltipKey = getTooltipKey(datum);
      if (!datumsByInteractionGroup2.has(interactionKey)) {
        datumsByInteractionGroup2.set(interactionKey, []);
      }
      if (!datumsByTooltipGroup2.has(tooltipKey)) {
        datumsByTooltipGroup2.set(tooltipKey, []);
      }
      datumsByInteractionGroup2.get(interactionKey).push(datum);
      datumsByTooltipGroup2.get(tooltipKey).push(datum);
    });
    datumsByInteractionGroup2.forEach(function(value, key) {
      datumsByInteractionGroup2.set(key, sortDatumsBySecondaryPx(value, secondaryAxes));
    });
    datumsByTooltipGroup2.forEach(function(value, key) {
      datumsByTooltipGroup2.set(key, sortDatumsBySecondaryPx(value, secondaryAxes));
    });
    allDatums.forEach(function(datum) {
      var interactionKey = getInteractionKey(datum);
      var tooltipKey = getTooltipKey(datum);
      datum.interactiveGroup = datumsByInteractionGroup2.get(interactionKey);
      datum.tooltipGroup = datumsByTooltipGroup2.get(tooltipKey);
    });
    return [datumsByInteractionGroup2, datumsByTooltipGroup2];
  }, [isInteracting, allDatums, options.interactionMode, primaryAxis, secondaryAxes, tooltipOptions.groupingMode]), datumsByInteractionGroup = _React$useMemo[0], datumsByTooltipGroup = _React$useMemo[1];
  var getSeriesStatusStyle = import_react16.default.useCallback(function(series2, focusedDatum2) {
    var _getOptions$getSeries, _getOptions$getSeries2, _getOptions;
    var base = {
      color: getOptions().defaultColors[series2.index % getOptions().defaultColors.length]
    };
    var status = getSeriesStatus(series2, focusedDatum2);
    var statusStyles = (_getOptions$getSeries = (_getOptions$getSeries2 = (_getOptions = getOptions()).getSeriesStyle) == null ? void 0 : _getOptions$getSeries2.call(_getOptions, series2, status)) != null ? _getOptions$getSeries : {};
    series2.style = materializeStyles(statusStyles, base);
    return series2.style;
  }, [getOptions]);
  var getDatumStatusStyle = import_react16.default.useCallback(function(datum, focusedDatum2) {
    var _series$datum$seriesI, _getOptions$getDatumS, _getOptions$getDatumS2, _getOptions2;
    var base = _extends({}, (_series$datum$seriesI = series[datum.seriesIndex]) == null ? void 0 : _series$datum$seriesI.style, {
      color: getOptions().defaultColors[datum.seriesIndex % getOptions().defaultColors.length]
    });
    var status = getDatumStatus(datum, focusedDatum2);
    var statusStyles = (_getOptions$getDatumS = (_getOptions$getDatumS2 = (_getOptions2 = getOptions()).getDatumStyle) == null ? void 0 : _getOptions$getDatumS2.call(_getOptions2, datum, status)) != null ? _getOptions$getDatumS : {};
    datum.style = materializeStyles(statusStyles, base);
    return datum.style;
  }, [getOptions, series]);
  var orderedSeries = import_react16.default.useMemo(function() {
    var reversedSeries = [].concat(series).reverse();
    return getOptions().getSeriesOrder(reversedSeries);
  }, [getOptions, series]);
  useIsomorphicLayoutEffect_default(function() {
    if (svgRef.current && svgRef.current.parentElement && !svgRef.current.parentElement.style.position) {
      svgRef.current.parentElement.style.position = "relative";
    }
  });
  var contextValue = {
    getOptions,
    gridDimensions,
    primaryAxis,
    secondaryAxes,
    series,
    orderedSeries,
    datumsByInteractionGroup,
    datumsByTooltipGroup,
    width,
    height,
    getSeriesStatusStyle,
    getDatumStatusStyle,
    axisDimensionsState,
    focusedDatumState,
    svgRef,
    isInteractingState
  };
  var seriesByAxisId = import_react16.default.useMemo(function() {
    return sort(groups(orderedSeries, function(d) {
      return d.secondaryAxisId;
    }), function(_ref3) {
      var key = _ref3[0];
      return secondaryAxes.findIndex(function(axis) {
        return axis.id === key;
      });
    });
  }, [orderedSeries, secondaryAxes]);
  var getSeriesInfo = function getSeriesInfo2() {
    return {
      primaryAxis,
      secondaryAxes,
      seriesByAxisId
    };
  };
  var getMemoizedSeriesInfo = import_react16.default.useCallback(function() {
    return {
      primaryAxis,
      secondaryAxes,
      seriesByAxisId
    };
  }, [primaryAxis, secondaryAxes, seriesByAxisId]);
  if (options.memoizeSeries) {
    getSeriesInfo = getMemoizedSeriesInfo;
  }
  var seriesEl = import_react16.default.useMemo(function() {
    var _getSeriesInfo = getSeriesInfo(), primaryAxis2 = _getSeriesInfo.primaryAxis, secondaryAxes2 = _getSeriesInfo.secondaryAxes, seriesByAxisId2 = _getSeriesInfo.seriesByAxisId;
    return seriesByAxisId2.map(function(_ref4) {
      var axisId = _ref4[0], series2 = _ref4[1];
      var secondaryAxis = secondaryAxes2.find(function(d) {
        return d.id === axisId;
      });
      if (!secondaryAxis) {
        return null;
      }
      var elementType = secondaryAxis.elementType;
      var Component = function() {
        if (elementType === "line" || elementType === "bubble" || elementType === "area") {
          return Line;
        }
        if (elementType === "bar") {
          return BarComponent;
        }
        throw new Error("Invalid elementType");
      }();
      if (primaryAxis2.isInvalid || secondaryAxis.isInvalid) {
        return null;
      }
      return import_react16.default.createElement(Component, {
        key: axisId != null ? axisId : "__default__",
        primaryAxis: primaryAxis2,
        secondaryAxis,
        series: series2
      });
    });
  }, [getSeriesInfo]);
  return import_react16.default.createElement(ChartContextProvider, {
    value: useGetLatest(contextValue)
  }, import_react16.default.createElement("div", null, import_react16.default.createElement("svg", {
    ref: svgRef,
    style: {
      width,
      height,
      overflow: options.brush ? "hidden" : "visible"
    },
    onClick: function onClick(e) {
      return options.onClickDatum == null ? void 0 : options.onClickDatum(focusedDatum, e);
    },
    onMouseEnter: function onMouseEnter() {
      isInteractingState[1](true);
    },
    onMouseLeave: function onMouseLeave() {
      isInteractingState[1](false);
    }
  }, import_react16.default.createElement("g", {
    className: "axes"
  }, [primaryAxis].concat(secondaryAxes).map(function(axis) {
    return import_react16.default.createElement(AxisLinearComp, _extends({
      key: [axis.position, axis.id].join("")
    }, axis));
  })), import_react16.default.createElement("g", {
    className: "Series",
    style: {
      pointerEvents: "none"
    }
  }, seriesEl), import_react16.default.createElement(Voronoi2, null), (_options$renderSVG = options.renderSVG == null ? void 0 : options.renderSVG()) != null ? _options$renderSVG : null), import_react16.default.createElement(Cursors, null), import_react16.default.createElement(Tooltip, null)));
}
function getFirstDefinedValue(options, data) {
  var firstDefinedValue;
  data.some(function(serie) {
    return serie.data.some(function(originalDatum) {
      var value = options.getValue(originalDatum);
      if (value !== null && typeof value !== "undefined") {
        firstDefinedValue = value;
        return true;
      }
    });
  });
  return firstDefinedValue;
}
function axisOptionsWithScaleType(options, firstValue) {
  var scaleType = options.scaleType;
  if (!options.scaleType) {
    if (typeof firstValue === "number") {
      scaleType = "linear";
    } else if (typeof (firstValue == null ? void 0 : firstValue.getMonth) === "function") {
      scaleType = "time";
    } else if (typeof firstValue === "string" || typeof firstValue === "boolean") {
      scaleType = "band";
    } else {
      throw new Error("Invalid scale type: Unable to infer type from data");
    }
  }
  return _extends({}, options, {
    scaleType
  });
}
function sortDatumsBySecondaryPx(datums, secondaryAxes) {
  if (secondaryAxes.every(function(d) {
    return d.stacked;
  })) {
    var differingInverts = secondaryAxes.some(function(d) {
      return d.invert;
    }) && secondaryAxes.some(function(d) {
      return !d.invert;
    });
    if (!differingInverts) {
      return datums;
    }
  }
  return [].concat(datums).sort(function(a2, b) {
    var _aAxis$scale, _a$stackData, _bAxis$scale, _b$stackData;
    var aAxis = secondaryAxes.find(function(d) {
      return d.id === a2.secondaryAxisId;
    });
    var bAxis = secondaryAxes.find(function(d) {
      return d.id === b.secondaryAxisId;
    });
    var aPx = (_aAxis$scale = aAxis == null ? void 0 : aAxis.scale(aAxis.stacked ? (_a$stackData = a2.stackData) == null ? void 0 : _a$stackData[1] : a2.secondaryValue)) != null ? _aAxis$scale : NaN;
    var bPx = (_bAxis$scale = bAxis == null ? void 0 : bAxis.scale(bAxis.stacked ? (_b$stackData = b.stackData) == null ? void 0 : _b$stackData[1] : b.secondaryValue)) != null ? _bAxis$scale : NaN;
    return aPx > bPx ? 1 : aPx < bPx ? -1 : 0;
  });
}
export {
  Chart
};
//# sourceMappingURL=react-charts.js.map
